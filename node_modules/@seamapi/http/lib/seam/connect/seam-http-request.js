import { serializeUrlSearchParams } from '@seamapi/url-search-params-serializer';
import { resolveActionAttempt } from './resolve-action-attempt.js';
import { SeamHttpActionAttempts } from './routes/index.js';
export class SeamHttpRequest {
    [Symbol.toStringTag] = 'SeamHttpRequest';
    #parent;
    #config;
    constructor(parent, config) {
        this.#parent = parent;
        this.#config = config;
    }
    get responseKey() {
        return this.#config.responseKey;
    }
    get url() {
        const { client } = this.#parent;
        const serializer = typeof client.defaults.paramsSerializer === 'function'
            ? client.defaults.paramsSerializer
            : serializeUrlSearchParams;
        const origin = getUrlPrefix(client.defaults.baseURL ?? '');
        const path = this.params == null
            ? this.pathname
            : `${this.pathname}?${serializer(this.params)}`;
        return new URL(`${origin}${path}`);
    }
    get pathname() {
        return this.#config.pathname.startsWith('/')
            ? this.#config.pathname
            : `/${this.#config.pathname}`;
    }
    get method() {
        return this.#config.method;
    }
    get params() {
        return this.#config.params;
    }
    get body() {
        return this.#config.body;
    }
    async execute() {
        const response = await this.fetchResponse();
        if (this.responseKey === undefined) {
            return undefined;
        }
        const data = response[this.responseKey];
        if (this.responseKey === 'action_attempt') {
            const waitForActionAttempt = this.#config.options?.waitForActionAttempt ??
                this.#parent.defaults.waitForActionAttempt;
            if (waitForActionAttempt !== false) {
                const actionAttempt = await resolveActionAttempt(data, SeamHttpActionAttempts.fromClient(this.#parent.client, {
                    ...this.#parent.defaults,
                    waitForActionAttempt: false,
                }), typeof waitForActionAttempt === 'boolean' ? {} : waitForActionAttempt);
                return actionAttempt;
            }
        }
        return data;
    }
    async fetchResponse() {
        const { client } = this.#parent;
        const response = await client.request({
            url: this.pathname,
            method: this.method,
            data: this.body,
            params: this.params,
        });
        return response.data;
    }
    async then(onfulfilled, onrejected) {
        return await this.execute().then(onfulfilled, onrejected);
    }
    async catch(onrejected) {
        return await this.execute().catch(onrejected);
    }
    async finally(onfinally) {
        return await this.execute().finally(onfinally);
    }
}
const getUrlPrefix = (input) => {
    if (canParseUrl(input)) {
        const url = new URL(input).toString();
        if (url.endsWith('/'))
            return url.slice(0, -1);
        return url;
    }
    if (globalThis.location != null) {
        const pathname = input.startsWith('/') ? input : `/${input}`;
        return new URL(`${globalThis.location.origin}${pathname}`).toString();
    }
    throw new Error(`Cannot resolve origin from ${input} in a non-browser environment`);
};
// UPSTREAM: Prefer URL.canParse when it has wider support.
// https://caniuse.com/mdn-api_url_canparse_static
const canParseUrl = (input) => {
    try {
        return new URL(input) != null;
    }
    catch {
        return false;
    }
};
//# sourceMappingURL=seam-http-request.js.map