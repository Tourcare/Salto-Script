import { SeamHttpRequest } from './seam-http-request.js';
export class SeamPaginator {
    #request;
    #parent;
    constructor(parent, request) {
        if (request.responseKey == null) {
            throw new Error(`The ${request.pathname} endpoint does not support pagination`);
        }
        this.#parent = parent;
        this.#request = request;
    }
    async firstPage() {
        return await this.#fetch();
    }
    async nextPage(nextPageCursor) {
        if (nextPageCursor == null) {
            throw new Error('Cannot get the next page with a null nextPageCursor');
        }
        return await this.#fetch(nextPageCursor);
    }
    async #fetch(nextPageCursor) {
        const responseKey = this.#request.responseKey;
        if (responseKey == null) {
            throw new Error('Cannot paginate a response without a responseKey');
        }
        const request = new SeamHttpRequest(this.#parent, {
            pathname: this.#request.pathname,
            method: this.#request.method,
            responseKey,
            params: this.#request.params != null
                ? { ...this.#request.params, page_cursor: nextPageCursor }
                : undefined,
            body: this.#request.body != null
                ? { ...this.#request.body, page_cursor: nextPageCursor }
                : undefined,
        });
        const response = await request.fetchResponse();
        const data = response[responseKey];
        const paginationData = response != null &&
            typeof response === 'object' &&
            'pagination' in response
            ? response.pagination
            : null;
        const pagination = {
            hasNextPage: paginationData?.has_next_page ?? false,
            nextPageCursor: paginationData?.next_page_cursor ?? null,
            nextPageUrl: paginationData?.next_page_url ?? null,
        };
        if (!Array.isArray(data)) {
            throw new Error(`Expected an array response for ${String(responseKey)} but got ${String(typeof data)}`);
        }
        return [
            data,
            pagination,
        ];
    }
    async flattenToArray() {
        const items = [];
        let [current, pagination] = await this.firstPage();
        items.push(...current);
        while (pagination.hasNextPage) {
            ;
            [current, pagination] = await this.nextPage(pagination.nextPageCursor);
            items.push(...current);
        }
        return items;
    }
    async *flatten() {
        let [current, pagination] = await this.firstPage();
        for (const item of current) {
            yield item;
        }
        while (pagination.hasNextPage) {
            ;
            [current, pagination] = await this.nextPage(pagination.nextPageCursor);
            for (const item of current) {
                yield item;
            }
        }
    }
    async *[Symbol.asyncIterator]() {
        let [current, pagination] = await this.firstPage();
        yield current;
        while (pagination.hasNextPage) {
            ;
            [current, pagination] = await this.nextPage(pagination.nextPageCursor);
            yield current;
        }
    }
}
//# sourceMappingURL=seam-paginator.js.map