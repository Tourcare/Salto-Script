/*
 * Automatically generated by codegen/smith.ts.
 * Do not edit this file or add other files to this directory.
 */
import { seamApiLtsVersion } from '../../../../lib/lts-version.js';
import { getAuthHeadersForClientSessionToken, warnOnInsecureuserIdentifierKey, } from '../../../../lib/seam/connect/auth.js';
import { createClient } from '../../../../lib/seam/connect/client.js';
import { isSeamHttpOptionsWithApiKey, isSeamHttpOptionsWithClient, isSeamHttpOptionsWithClientSessionToken, isSeamHttpOptionsWithConsoleSessionToken, isSeamHttpOptionsWithPersonalAccessToken, SeamHttpInvalidOptionsError, } from '../../../../lib/seam/connect/options.js';
import { limitToSeamHttpRequestOptions, parseOptions, } from '../../../../lib/seam/connect/parse-options.js';
import { SeamPaginator } from '../../../../lib/seam/connect/seam-paginator.js';
import { SeamHttpAccessCodes } from './access-codes/index.js';
import { SeamHttpAccessGrants } from './access-grants/index.js';
import { SeamHttpAccessMethods } from './access-methods/index.js';
import { SeamHttpAcs } from './acs/index.js';
import { SeamHttpActionAttempts } from './action-attempts/index.js';
import { SeamHttpBridges } from './bridges/index.js';
import { SeamHttpClientSessions } from './client-sessions/index.js';
import { SeamHttpConnectWebviews } from './connect-webviews/index.js';
import { SeamHttpConnectedAccounts } from './connected-accounts/index.js';
import { SeamHttpCustomers } from './customers/index.js';
import { SeamHttpDevices } from './devices/index.js';
import { SeamHttpEvents } from './events/index.js';
import { SeamHttpInstantKeys } from './instant-keys/index.js';
import { SeamHttpLocks } from './locks/index.js';
import { SeamHttpNoiseSensors } from './noise-sensors/index.js';
import { SeamHttpPhones } from './phones/index.js';
import { SeamHttpSpaces } from './spaces/index.js';
import { SeamHttpThermostats } from './thermostats/index.js';
import { SeamHttpUnstablePartner } from './unstable-partner/index.js';
import { SeamHttpUserIdentities } from './user-identities/index.js';
import { SeamHttpWebhooks } from './webhooks/index.js';
import { SeamHttpWorkspaces } from './workspaces/index.js';
export class SeamHttp {
    client;
    defaults;
    ltsVersion = seamApiLtsVersion;
    static ltsVersion = seamApiLtsVersion;
    constructor(apiKeyOrOptions = {}) {
        const options = parseOptions(apiKeyOrOptions);
        this.client = 'client' in options ? options.client : createClient(options);
        this.defaults = limitToSeamHttpRequestOptions(options);
    }
    static fromClient(client, options = {}) {
        const constructorOptions = { ...options, client };
        if (!isSeamHttpOptionsWithClient(constructorOptions)) {
            throw new SeamHttpInvalidOptionsError('Missing client');
        }
        return new SeamHttp(constructorOptions);
    }
    static fromApiKey(apiKey, options = {}) {
        const constructorOptions = { ...options, apiKey };
        if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
            throw new SeamHttpInvalidOptionsError('Missing apiKey');
        }
        return new SeamHttp(constructorOptions);
    }
    static fromClientSessionToken(clientSessionToken, options = {}) {
        const constructorOptions = { ...options, clientSessionToken };
        if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
            throw new SeamHttpInvalidOptionsError('Missing clientSessionToken');
        }
        return new SeamHttp(constructorOptions);
    }
    static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
        warnOnInsecureuserIdentifierKey(userIdentifierKey);
        const clientOptions = parseOptions({ ...options, publishableKey });
        if (isSeamHttpOptionsWithClient(clientOptions)) {
            throw new SeamHttpInvalidOptionsError('The client option cannot be used with SeamHttp.fromPublishableKey');
        }
        const client = createClient(clientOptions);
        const clientSessions = SeamHttpClientSessions.fromClient(client);
        const { token } = await clientSessions.getOrCreate({
            user_identifier_key: userIdentifierKey,
        });
        return SeamHttp.fromClientSessionToken(token, options);
    }
    static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
        const constructorOptions = { ...options, consoleSessionToken, workspaceId };
        if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
            throw new SeamHttpInvalidOptionsError('Missing consoleSessionToken or workspaceId');
        }
        return new SeamHttp(constructorOptions);
    }
    static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
        const constructorOptions = { ...options, personalAccessToken, workspaceId };
        if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
            throw new SeamHttpInvalidOptionsError('Missing personalAccessToken or workspaceId');
        }
        return new SeamHttp(constructorOptions);
    }
    createPaginator(request) {
        return new SeamPaginator(this, request);
    }
    async updateClientSessionToken(clientSessionToken) {
        const { headers } = this.client.defaults;
        const authHeaders = getAuthHeadersForClientSessionToken({
            clientSessionToken,
        });
        for (const key of Object.keys(authHeaders)) {
            if (headers[key] == null) {
                throw new Error('Cannot update a clientSessionToken on a client created without a clientSessionToken');
            }
        }
        this.client.defaults.headers = { ...headers, ...authHeaders };
        const clientSessions = SeamHttpClientSessions.fromClient(this.client);
        await clientSessions.get();
    }
    get accessCodes() {
        return SeamHttpAccessCodes.fromClient(this.client, this.defaults);
    }
    get accessGrants() {
        return SeamHttpAccessGrants.fromClient(this.client, this.defaults);
    }
    get accessMethods() {
        return SeamHttpAccessMethods.fromClient(this.client, this.defaults);
    }
    get acs() {
        return SeamHttpAcs.fromClient(this.client, this.defaults);
    }
    get actionAttempts() {
        return SeamHttpActionAttempts.fromClient(this.client, this.defaults);
    }
    get bridges() {
        return SeamHttpBridges.fromClient(this.client, this.defaults);
    }
    get clientSessions() {
        return SeamHttpClientSessions.fromClient(this.client, this.defaults);
    }
    get connectWebviews() {
        return SeamHttpConnectWebviews.fromClient(this.client, this.defaults);
    }
    get connectedAccounts() {
        return SeamHttpConnectedAccounts.fromClient(this.client, this.defaults);
    }
    get customers() {
        return SeamHttpCustomers.fromClient(this.client, this.defaults);
    }
    get devices() {
        return SeamHttpDevices.fromClient(this.client, this.defaults);
    }
    get events() {
        return SeamHttpEvents.fromClient(this.client, this.defaults);
    }
    get instantKeys() {
        return SeamHttpInstantKeys.fromClient(this.client, this.defaults);
    }
    get locks() {
        return SeamHttpLocks.fromClient(this.client, this.defaults);
    }
    get noiseSensors() {
        return SeamHttpNoiseSensors.fromClient(this.client, this.defaults);
    }
    get phones() {
        return SeamHttpPhones.fromClient(this.client, this.defaults);
    }
    get spaces() {
        return SeamHttpSpaces.fromClient(this.client, this.defaults);
    }
    get thermostats() {
        return SeamHttpThermostats.fromClient(this.client, this.defaults);
    }
    get unstablePartner() {
        return SeamHttpUnstablePartner.fromClient(this.client, this.defaults);
    }
    get userIdentities() {
        return SeamHttpUserIdentities.fromClient(this.client, this.defaults);
    }
    get webhooks() {
        return SeamHttpWebhooks.fromClient(this.client, this.defaults);
    }
    get workspaces() {
        return SeamHttpWorkspaces.fromClient(this.client, this.defaults);
    }
}
//# sourceMappingURL=seam-http.js.map