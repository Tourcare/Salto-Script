import type { Client } from './client.js';
import type { SeamHttpRequestOptions } from './options.js';
import { SeamHttpRequest } from './seam-http-request.js';
interface SeamPaginatorParent {
    readonly client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
}
declare const $brand: unique symbol;
export type SeamPageCursor = string & {
    [$brand]: 'SeamPageCursor';
};
interface Pagination {
    readonly hasNextPage: boolean;
    readonly nextPageCursor: SeamPageCursor | null;
    readonly nextPageUrl: string | null;
}
export declare class SeamPaginator<const TResponse, const TResponseKey extends keyof TResponse> implements AsyncIterable<EnsureReadonlyArray<TResponse[TResponseKey]>> {
    #private;
    constructor(parent: SeamPaginatorParent, request: SeamHttpRequest<TResponse, TResponseKey>);
    firstPage(): Promise<[
        EnsureReadonlyArray<TResponse[TResponseKey]>,
        Pagination
    ]>;
    nextPage(nextPageCursor: Pagination['nextPageCursor']): Promise<[EnsureReadonlyArray<TResponse[TResponseKey]>, Pagination]>;
    flattenToArray(): Promise<EnsureReadonlyArray<TResponse[TResponseKey]>>;
    flatten(): AsyncGenerator<EnsureReadonlyArray<TResponse[TResponseKey]>>;
    [Symbol.asyncIterator](): AsyncGenerator<EnsureReadonlyArray<TResponse[TResponseKey]>>;
}
type EnsureReadonlyArray<T> = T extends readonly any[] ? T : never;
export {};
