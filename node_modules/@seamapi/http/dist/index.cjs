'use strict';

var axios = require('axios');
var url_search_params_serializer_star = require('@seamapi/url-search-params-serializer');
var axiosRetry = require('axios-retry');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var axios__default = /*#__PURE__*/_interopDefault(axios);
var url_search_params_serializer_star__namespace = /*#__PURE__*/_interopNamespace(url_search_params_serializer_star);
var axiosRetry__default = /*#__PURE__*/_interopDefault(axiosRetry);

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  SeamActionAttemptError: () => SeamActionAttemptError,
  SeamActionAttemptFailedError: () => SeamActionAttemptFailedError,
  SeamActionAttemptTimeoutError: () => SeamActionAttemptTimeoutError,
  SeamHttp: () => SeamHttp,
  SeamHttpAccessCodes: () => SeamHttpAccessCodes,
  SeamHttpAccessCodesSimulate: () => SeamHttpAccessCodesSimulate,
  SeamHttpAccessCodesUnmanaged: () => SeamHttpAccessCodesUnmanaged,
  SeamHttpAccessGrants: () => SeamHttpAccessGrants,
  SeamHttpAccessGrantsUnmanaged: () => SeamHttpAccessGrantsUnmanaged,
  SeamHttpAccessMethods: () => SeamHttpAccessMethods,
  SeamHttpAccessMethodsUnmanaged: () => SeamHttpAccessMethodsUnmanaged,
  SeamHttpAcs: () => SeamHttpAcs,
  SeamHttpAcsAccessGroups: () => SeamHttpAcsAccessGroups,
  SeamHttpAcsAccessGroupsUnmanaged: () => SeamHttpAcsAccessGroupsUnmanaged,
  SeamHttpAcsCredentialPools: () => SeamHttpAcsCredentialPools,
  SeamHttpAcsCredentialProvisioningAutomations: () => SeamHttpAcsCredentialProvisioningAutomations,
  SeamHttpAcsCredentials: () => SeamHttpAcsCredentials,
  SeamHttpAcsCredentialsUnmanaged: () => SeamHttpAcsCredentialsUnmanaged,
  SeamHttpAcsEncoders: () => SeamHttpAcsEncoders,
  SeamHttpAcsEncodersSimulate: () => SeamHttpAcsEncodersSimulate,
  SeamHttpAcsEntrances: () => SeamHttpAcsEntrances,
  SeamHttpAcsSystems: () => SeamHttpAcsSystems,
  SeamHttpAcsUsers: () => SeamHttpAcsUsers,
  SeamHttpAcsUsersUnmanaged: () => SeamHttpAcsUsersUnmanaged,
  SeamHttpActionAttempts: () => SeamHttpActionAttempts,
  SeamHttpApiError: () => SeamHttpApiError,
  SeamHttpBridges: () => SeamHttpBridges,
  SeamHttpClientSessions: () => SeamHttpClientSessions,
  SeamHttpConnectWebviews: () => SeamHttpConnectWebviews,
  SeamHttpConnectedAccounts: () => SeamHttpConnectedAccounts,
  SeamHttpCustomers: () => SeamHttpCustomers,
  SeamHttpDevices: () => SeamHttpDevices,
  SeamHttpDevicesSimulate: () => SeamHttpDevicesSimulate,
  SeamHttpDevicesUnmanaged: () => SeamHttpDevicesUnmanaged,
  SeamHttpEndpoints: () => SeamHttpEndpoints,
  SeamHttpEndpointsWithoutWorkspace: () => SeamHttpEndpointsWithoutWorkspace,
  SeamHttpEvents: () => SeamHttpEvents,
  SeamHttpInstantKeys: () => SeamHttpInstantKeys,
  SeamHttpInvalidInputError: () => SeamHttpInvalidInputError,
  SeamHttpInvalidOptionsError: () => SeamHttpInvalidOptionsError,
  SeamHttpInvalidTokenError: () => SeamHttpInvalidTokenError,
  SeamHttpLocks: () => SeamHttpLocks,
  SeamHttpLocksSimulate: () => SeamHttpLocksSimulate,
  SeamHttpMultiWorkspace: () => SeamHttpMultiWorkspace,
  SeamHttpNoiseSensors: () => SeamHttpNoiseSensors,
  SeamHttpNoiseSensorsNoiseThresholds: () => SeamHttpNoiseSensorsNoiseThresholds,
  SeamHttpNoiseSensorsSimulate: () => SeamHttpNoiseSensorsSimulate,
  SeamHttpPhones: () => SeamHttpPhones,
  SeamHttpPhonesSimulate: () => SeamHttpPhonesSimulate,
  SeamHttpRequest: () => SeamHttpRequest,
  SeamHttpSeamConsole: () => SeamHttpSeamConsole,
  SeamHttpSeamConsoleV1: () => SeamHttpSeamConsoleV1,
  SeamHttpSeamConsoleV1Timelines: () => SeamHttpSeamConsoleV1Timelines,
  SeamHttpSeamCustomerV1: () => SeamHttpSeamCustomerV1,
  SeamHttpSeamCustomerV1AutomationRuns: () => SeamHttpSeamCustomerV1AutomationRuns,
  SeamHttpSeamCustomerV1Automations: () => SeamHttpSeamCustomerV1Automations,
  SeamHttpSeamCustomerV1Events: () => SeamHttpSeamCustomerV1Events,
  SeamHttpSeamCustomerV1Portals: () => SeamHttpSeamCustomerV1Portals,
  SeamHttpSeamCustomerV1Reservations: () => SeamHttpSeamCustomerV1Reservations,
  SeamHttpSeamCustomerV1Settings: () => SeamHttpSeamCustomerV1Settings,
  SeamHttpSeamCustomerV1Spaces: () => SeamHttpSeamCustomerV1Spaces,
  SeamHttpSeamPartnerV1BuildingBlocks: () => SeamHttpSeamPartnerV1BuildingBlocks,
  SeamHttpSeamPartnerV1BuildingBlocksSpaces: () => SeamHttpSeamPartnerV1BuildingBlocksSpaces,
  SeamHttpSpaces: () => SeamHttpSpaces,
  SeamHttpThermostats: () => SeamHttpThermostats,
  SeamHttpThermostatsDailyPrograms: () => SeamHttpThermostatsDailyPrograms,
  SeamHttpThermostatsSchedules: () => SeamHttpThermostatsSchedules,
  SeamHttpThermostatsSimulate: () => SeamHttpThermostatsSimulate,
  SeamHttpUnauthorizedError: () => SeamHttpUnauthorizedError,
  SeamHttpUnstablePartner: () => SeamHttpUnstablePartner,
  SeamHttpUnstablePartnerBuildingBlocks: () => SeamHttpUnstablePartnerBuildingBlocks,
  SeamHttpUserIdentities: () => SeamHttpUserIdentities,
  SeamHttpUserIdentitiesEnrollmentAutomations: () => SeamHttpUserIdentitiesEnrollmentAutomations,
  SeamHttpUserIdentitiesUnmanaged: () => SeamHttpUserIdentitiesUnmanaged,
  SeamHttpWebhooks: () => SeamHttpWebhooks,
  SeamHttpWithoutWorkspace: () => SeamHttpWithoutWorkspace,
  SeamHttpWithoutWorkspaceInvalidOptionsError: () => SeamHttpWithoutWorkspaceInvalidOptionsError,
  SeamHttpWorkspaces: () => SeamHttpWorkspaces,
  SeamHttpWorkspacesCustomizationProfiles: () => SeamHttpWorkspacesCustomizationProfiles,
  SeamPaginator: () => SeamPaginator,
  errorInterceptor: () => errorInterceptor,
  getOpenapiSchema: () => getOpenapiSchema,
  isApiKey: () => isApiKey,
  isClientSessionToken: () => isClientSessionToken,
  isConsoleSessionToken: () => isConsoleSessionToken,
  isPersonalAccessToken: () => isPersonalAccessToken,
  isPublishableKey: () => isPublishableKey,
  isSeamActionAttemptError: () => isSeamActionAttemptError,
  isSeamActionAttemptFailedError: () => isSeamActionAttemptFailedError,
  isSeamActionAttemptTimeoutError: () => isSeamActionAttemptTimeoutError,
  isSeamHttpApiError: () => isSeamHttpApiError,
  isSeamHttpInvalidInputError: () => isSeamHttpInvalidInputError,
  isSeamHttpOptionsWithApiKey: () => isSeamHttpOptionsWithApiKey,
  isSeamHttpOptionsWithClient: () => isSeamHttpOptionsWithClient,
  isSeamHttpOptionsWithClientSessionToken: () => isSeamHttpOptionsWithClientSessionToken,
  isSeamHttpOptionsWithConsoleSessionToken: () => isSeamHttpOptionsWithConsoleSessionToken,
  isSeamHttpOptionsWithPersonalAccessToken: () => isSeamHttpOptionsWithPersonalAccessToken,
  isSeamHttpUnauthorizedError: () => isSeamHttpUnauthorizedError,
  isSeamHttpWithoutWorkspaceOptionsWithClient: () => isSeamHttpWithoutWorkspaceOptionsWithClient,
  isSeamHttpWithoutWorkspaceOptionsWithConsoleSessionToken: () => isSeamHttpWithoutWorkspaceOptionsWithConsoleSessionToken,
  isSeamHttpWithoutWorkspaceOptionsWithPersonalAccessToken: () => isSeamHttpWithoutWorkspaceOptionsWithPersonalAccessToken
});

// src/connect.ts
var connect_exports = {};
__export(connect_exports, {
  SeamActionAttemptError: () => SeamActionAttemptError,
  SeamActionAttemptFailedError: () => SeamActionAttemptFailedError,
  SeamActionAttemptTimeoutError: () => SeamActionAttemptTimeoutError,
  SeamHttp: () => SeamHttp,
  SeamHttpAccessCodes: () => SeamHttpAccessCodes,
  SeamHttpAccessCodesSimulate: () => SeamHttpAccessCodesSimulate,
  SeamHttpAccessCodesUnmanaged: () => SeamHttpAccessCodesUnmanaged,
  SeamHttpAccessGrants: () => SeamHttpAccessGrants,
  SeamHttpAccessGrantsUnmanaged: () => SeamHttpAccessGrantsUnmanaged,
  SeamHttpAccessMethods: () => SeamHttpAccessMethods,
  SeamHttpAccessMethodsUnmanaged: () => SeamHttpAccessMethodsUnmanaged,
  SeamHttpAcs: () => SeamHttpAcs,
  SeamHttpAcsAccessGroups: () => SeamHttpAcsAccessGroups,
  SeamHttpAcsAccessGroupsUnmanaged: () => SeamHttpAcsAccessGroupsUnmanaged,
  SeamHttpAcsCredentialPools: () => SeamHttpAcsCredentialPools,
  SeamHttpAcsCredentialProvisioningAutomations: () => SeamHttpAcsCredentialProvisioningAutomations,
  SeamHttpAcsCredentials: () => SeamHttpAcsCredentials,
  SeamHttpAcsCredentialsUnmanaged: () => SeamHttpAcsCredentialsUnmanaged,
  SeamHttpAcsEncoders: () => SeamHttpAcsEncoders,
  SeamHttpAcsEncodersSimulate: () => SeamHttpAcsEncodersSimulate,
  SeamHttpAcsEntrances: () => SeamHttpAcsEntrances,
  SeamHttpAcsSystems: () => SeamHttpAcsSystems,
  SeamHttpAcsUsers: () => SeamHttpAcsUsers,
  SeamHttpAcsUsersUnmanaged: () => SeamHttpAcsUsersUnmanaged,
  SeamHttpActionAttempts: () => SeamHttpActionAttempts,
  SeamHttpApiError: () => SeamHttpApiError,
  SeamHttpBridges: () => SeamHttpBridges,
  SeamHttpClientSessions: () => SeamHttpClientSessions,
  SeamHttpConnectWebviews: () => SeamHttpConnectWebviews,
  SeamHttpConnectedAccounts: () => SeamHttpConnectedAccounts,
  SeamHttpCustomers: () => SeamHttpCustomers,
  SeamHttpDevices: () => SeamHttpDevices,
  SeamHttpDevicesSimulate: () => SeamHttpDevicesSimulate,
  SeamHttpDevicesUnmanaged: () => SeamHttpDevicesUnmanaged,
  SeamHttpEndpoints: () => SeamHttpEndpoints,
  SeamHttpEndpointsWithoutWorkspace: () => SeamHttpEndpointsWithoutWorkspace,
  SeamHttpEvents: () => SeamHttpEvents,
  SeamHttpInstantKeys: () => SeamHttpInstantKeys,
  SeamHttpInvalidInputError: () => SeamHttpInvalidInputError,
  SeamHttpInvalidOptionsError: () => SeamHttpInvalidOptionsError,
  SeamHttpInvalidTokenError: () => SeamHttpInvalidTokenError,
  SeamHttpLocks: () => SeamHttpLocks,
  SeamHttpLocksSimulate: () => SeamHttpLocksSimulate,
  SeamHttpMultiWorkspace: () => SeamHttpMultiWorkspace,
  SeamHttpNoiseSensors: () => SeamHttpNoiseSensors,
  SeamHttpNoiseSensorsNoiseThresholds: () => SeamHttpNoiseSensorsNoiseThresholds,
  SeamHttpNoiseSensorsSimulate: () => SeamHttpNoiseSensorsSimulate,
  SeamHttpPhones: () => SeamHttpPhones,
  SeamHttpPhonesSimulate: () => SeamHttpPhonesSimulate,
  SeamHttpRequest: () => SeamHttpRequest,
  SeamHttpSeamConsole: () => SeamHttpSeamConsole,
  SeamHttpSeamConsoleV1: () => SeamHttpSeamConsoleV1,
  SeamHttpSeamConsoleV1Timelines: () => SeamHttpSeamConsoleV1Timelines,
  SeamHttpSeamCustomerV1: () => SeamHttpSeamCustomerV1,
  SeamHttpSeamCustomerV1AutomationRuns: () => SeamHttpSeamCustomerV1AutomationRuns,
  SeamHttpSeamCustomerV1Automations: () => SeamHttpSeamCustomerV1Automations,
  SeamHttpSeamCustomerV1Events: () => SeamHttpSeamCustomerV1Events,
  SeamHttpSeamCustomerV1Portals: () => SeamHttpSeamCustomerV1Portals,
  SeamHttpSeamCustomerV1Reservations: () => SeamHttpSeamCustomerV1Reservations,
  SeamHttpSeamCustomerV1Settings: () => SeamHttpSeamCustomerV1Settings,
  SeamHttpSeamCustomerV1Spaces: () => SeamHttpSeamCustomerV1Spaces,
  SeamHttpSeamPartnerV1BuildingBlocks: () => SeamHttpSeamPartnerV1BuildingBlocks,
  SeamHttpSeamPartnerV1BuildingBlocksSpaces: () => SeamHttpSeamPartnerV1BuildingBlocksSpaces,
  SeamHttpSpaces: () => SeamHttpSpaces,
  SeamHttpThermostats: () => SeamHttpThermostats,
  SeamHttpThermostatsDailyPrograms: () => SeamHttpThermostatsDailyPrograms,
  SeamHttpThermostatsSchedules: () => SeamHttpThermostatsSchedules,
  SeamHttpThermostatsSimulate: () => SeamHttpThermostatsSimulate,
  SeamHttpUnauthorizedError: () => SeamHttpUnauthorizedError,
  SeamHttpUnstablePartner: () => SeamHttpUnstablePartner,
  SeamHttpUnstablePartnerBuildingBlocks: () => SeamHttpUnstablePartnerBuildingBlocks,
  SeamHttpUserIdentities: () => SeamHttpUserIdentities,
  SeamHttpUserIdentitiesEnrollmentAutomations: () => SeamHttpUserIdentitiesEnrollmentAutomations,
  SeamHttpUserIdentitiesUnmanaged: () => SeamHttpUserIdentitiesUnmanaged,
  SeamHttpWebhooks: () => SeamHttpWebhooks,
  SeamHttpWithoutWorkspace: () => SeamHttpWithoutWorkspace,
  SeamHttpWithoutWorkspaceInvalidOptionsError: () => SeamHttpWithoutWorkspaceInvalidOptionsError,
  SeamHttpWorkspaces: () => SeamHttpWorkspaces,
  SeamHttpWorkspacesCustomizationProfiles: () => SeamHttpWorkspacesCustomizationProfiles,
  SeamPaginator: () => SeamPaginator,
  errorInterceptor: () => errorInterceptor,
  getOpenapiSchema: () => getOpenapiSchema,
  isApiKey: () => isApiKey,
  isClientSessionToken: () => isClientSessionToken,
  isConsoleSessionToken: () => isConsoleSessionToken,
  isPersonalAccessToken: () => isPersonalAccessToken,
  isPublishableKey: () => isPublishableKey,
  isSeamActionAttemptError: () => isSeamActionAttemptError,
  isSeamActionAttemptFailedError: () => isSeamActionAttemptFailedError,
  isSeamActionAttemptTimeoutError: () => isSeamActionAttemptTimeoutError,
  isSeamHttpApiError: () => isSeamHttpApiError,
  isSeamHttpInvalidInputError: () => isSeamHttpInvalidInputError,
  isSeamHttpOptionsWithApiKey: () => isSeamHttpOptionsWithApiKey,
  isSeamHttpOptionsWithClient: () => isSeamHttpOptionsWithClient,
  isSeamHttpOptionsWithClientSessionToken: () => isSeamHttpOptionsWithClientSessionToken,
  isSeamHttpOptionsWithConsoleSessionToken: () => isSeamHttpOptionsWithConsoleSessionToken,
  isSeamHttpOptionsWithPersonalAccessToken: () => isSeamHttpOptionsWithPersonalAccessToken,
  isSeamHttpUnauthorizedError: () => isSeamHttpUnauthorizedError,
  isSeamHttpWithoutWorkspaceOptionsWithClient: () => isSeamHttpWithoutWorkspaceOptionsWithClient,
  isSeamHttpWithoutWorkspaceOptionsWithConsoleSessionToken: () => isSeamHttpWithoutWorkspaceOptionsWithConsoleSessionToken,
  isSeamHttpWithoutWorkspaceOptionsWithPersonalAccessToken: () => isSeamHttpWithoutWorkspaceOptionsWithPersonalAccessToken
});

// src/lib/lts-version.ts
var seamApiLtsVersion = "1.0.0";

// src/lib/version.ts
var seamapiJavascriptHttpVersion = "0.0.0";
var version_default = seamapiJavascriptHttpVersion;

// src/lib/seam/connect/parse-options.ts
var defaultEndpoint = "https://connect.getseam.com";
var sdkHeaders = {
  "seam-sdk-name": "seamapi/javascript-http",
  "seam-sdk-version": version_default,
  "seam-lts-version": seamApiLtsVersion
};
var parseOptions = (apiKeyOrOptions) => {
  const options = getNormalizedOptions(apiKeyOrOptions);
  if (isSeamHttpOptionsWithClient(options)) return options;
  if (isSeamHttpWithoutWorkspaceOptionsWithClient(options)) return options;
  return {
    ...options,
    axiosOptions: {
      baseURL: options.endpoint ?? getEndpointFromEnv() ?? defaultEndpoint,
      withCredentials: isSeamHttpOptionsWithClientSessionToken(options),
      ...options.axiosOptions,
      headers: {
        ...getAuthHeaders(options),
        ...options.axiosOptions?.headers,
        ...sdkHeaders
      }
    },
    axiosRetryOptions: {
      ...options.axiosRetryOptions
    }
  };
};
var getNormalizedOptions = (apiKeyOrOptions) => {
  const options = typeof apiKeyOrOptions === "string" ? { apiKey: apiKeyOrOptions } : apiKeyOrOptions;
  const requestOptions = {
    isUndocumentedApiEnabled: options.isUndocumentedApiEnabled ?? false,
    waitForActionAttempt: options.waitForActionAttempt ?? true
  };
  if (isSeamHttpOptionsWithClient(options)) {
    return {
      ...options,
      ...requestOptions
    };
  }
  const apiKey = "apiKey" in options ? options.apiKey : getApiKeyFromEnv(options);
  const personalAccessToken = "personalAccessToken" in options ? options.personalAccessToken : getPersonalAccessTokenFromEnv(options);
  const workspaceId = "workspaceId" in options ? options.workspaceId : getWorkspaceIdFromEnv();
  if (apiKey != null && personalAccessToken != null && !("apiKey" in options) && !("personalAccessToken" in options)) {
    throw new SeamHttpInvalidOptionsError(
      "Both SEAM_API_KEY and SEAM_PERSONAL_ACCESS_TOKEN environment variables are defined. Please use only one authentication method."
    );
  }
  return {
    ...options,
    ...apiKey != null ? { apiKey } : {},
    ...workspaceId != null ? { workspaceId } : {},
    ...personalAccessToken != null ? { personalAccessToken } : {},
    ...requestOptions
  };
};
var getApiKeyFromEnv = (options) => {
  if ("clientSessionToken" in options && options.clientSessionToken != null) {
    return null;
  }
  if ("consoleSessionToken" in options && options.consoleSessionToken != null) {
    return null;
  }
  if ("personalAccessToken" in options && options.personalAccessToken != null) {
    return null;
  }
  return globalThis.process?.env?.SEAM_API_KEY;
};
var getPersonalAccessTokenFromEnv = (options) => {
  if ("apiKey" in options && options.apiKey != null) {
    return null;
  }
  if ("clientSessionToken" in options && options.clientSessionToken != null) {
    return null;
  }
  if ("consoleSessionToken" in options && options.consoleSessionToken != null) {
    return null;
  }
  return globalThis.process?.env?.SEAM_PERSONAL_ACCESS_TOKEN;
};
var getWorkspaceIdFromEnv = () => {
  return globalThis.process?.env?.SEAM_WORKSPACE_ID;
};
var getEndpointFromEnv = () => {
  if (globalThis.process?.env?.SEAM_API_URL != null) {
    console.warn(
      "Using the SEAM_API_URL environment variable is deprecated. Support will be remove in a later major version. Use SEAM_ENDPOINT instead."
    );
  }
  if (globalThis.process?.env?.SEAM_API_URL != null && globalThis.process?.env?.SEAM_ENDPOINT != null) {
    console.warn(
      "Detected both the SEAM_API_URL and SEAM_ENDPOINT environment variables. Using SEAM_ENDPOINT."
    );
  }
  return globalThis.process?.env?.SEAM_ENDPOINT ?? globalThis.process?.env?.SEAM_API_URL;
};
var limitToSeamHttpRequestOptions = (options) => {
  return Object.keys(options).filter(isSeamHttpRequestOption).reduce(
    (obj, key) => ({
      ...obj,
      [key]: options[key]
    }),
    {}
  );
};
var isSeamHttpRequestOption = (key) => {
  const keys = {
    isUndocumentedApiEnabled: true,
    waitForActionAttempt: true
  };
  return Object.keys(keys).includes(key);
};

// src/lib/seam/connect/options.ts
var isSeamHttpWithoutWorkspaceOptionsWithClient = (options) => isSeamHttpOptionsWithClient(options);
var isSeamHttpOptionsWithClient = (options) => {
  if (!("client" in options)) return false;
  if (options.client == null) return false;
  const keys = Object.keys(options).filter((k) => k !== "client");
  if (keys.filter((k) => !isSeamHttpRequestOption(k)).length > 0) {
    throw new SeamHttpInvalidOptionsError(
      `The client option cannot be used with any other option, but received: ${keys.join(
        ", "
      )}`
    );
  }
  return true;
};
var isSeamHttpOptionsWithApiKey = (options) => {
  if (!("apiKey" in options)) return false;
  if (options.apiKey == null) return false;
  if ("clientSessionToken" in options && options.clientSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The clientSessionToken option cannot be used with the apiKey option"
    );
  }
  if ("consoleSessionToken" in options && options.consoleSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The consoleSessionToken option cannot be used with the apiKey option"
    );
  }
  if ("personalAccessToken" in options && options.personalAccessToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The personalAccessToken option cannot be used with the apiKey option"
    );
  }
  return true;
};
var isSeamHttpOptionsWithClientSessionToken = (options) => {
  if (!("clientSessionToken" in options)) return false;
  if (options.clientSessionToken == null) return false;
  if ("apiKey" in options && options.apiKey != null) {
    throw new SeamHttpInvalidOptionsError(
      "The apiKey option cannot be used with the clientSessionToken option"
    );
  }
  if ("consoleSessionToken" in options && options.consoleSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The consoleSessionToken option cannot be used with the clientSessionToken option"
    );
  }
  if ("personalAccessToken" in options && options.personalAccessToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The personalAccessToken option cannot be used with the clientSessionToken option"
    );
  }
  return true;
};
var isSeamHttpWithoutWorkspaceOptionsWithConsoleSessionToken = (options) => {
  if (!("consoleSessionToken" in options)) return false;
  if (options.consoleSessionToken == null) return false;
  if ("apiKey" in options && options.apiKey != null) {
    throw new SeamHttpInvalidOptionsError(
      "The apiKey option cannot be used with the consoleSessionToken option"
    );
  }
  if ("clientSessionToken" in options && options.clientSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The clientSessionToken option cannot be used with the consoleSessionToken option"
    );
  }
  if ("personalAccessToken" in options && options.personalAccessToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The personalAccessToken option cannot be used with the consoleSessionToken option"
    );
  }
  return true;
};
var isSeamHttpOptionsWithConsoleSessionToken = (options) => {
  if (!isSeamHttpWithoutWorkspaceOptionsWithConsoleSessionToken(options)) {
    return false;
  }
  if (!("workspaceId" in options) || options.workspaceId == null) {
    throw new SeamHttpInvalidOptionsError(
      "Must pass a workspaceId when using a consoleSessionToken"
    );
  }
  return true;
};
var isSeamHttpWithoutWorkspaceOptionsWithPersonalAccessToken = (options) => {
  if (!("personalAccessToken" in options)) return false;
  if (options.personalAccessToken == null) return false;
  if ("apiKey" in options && options.apiKey != null) {
    throw new SeamHttpInvalidOptionsError(
      "The apiKey option cannot be used with the personalAccessToken option"
    );
  }
  if ("clientSessionToken" in options && options.clientSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The clientSessionToken option cannot be used with the personalAccessToken option"
    );
  }
  if ("consoleSessionToken" in options && options.consoleSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The consoleSessionToken option cannot be used with the personalAccessToken option"
    );
  }
  return true;
};
var isSeamHttpOptionsWithPersonalAccessToken = (options) => {
  if (!isSeamHttpWithoutWorkspaceOptionsWithPersonalAccessToken(options)) {
    return false;
  }
  if (!("workspaceId" in options) || options.workspaceId == null) {
    throw new SeamHttpInvalidOptionsError(
      "Must pass a workspaceId when using a personalAccessToken"
    );
  }
  return true;
};
var SeamHttpInvalidOptionsError = class extends Error {
  constructor(message) {
    super(`SeamHttp received invalid options: ${message}`);
    this.name = this.constructor.name;
  }
};
var SeamHttpWithoutWorkspaceInvalidOptionsError = class extends Error {
  constructor(message) {
    super(`SeamHttpWithoutWorkspace received invalid options: ${message}`);
    this.name = this.constructor.name;
  }
};

// src/lib/seam/connect/token.ts
var tokenPrefix = "seam_";
var accessTokenPrefix = "seam_at";
var jwtPrefix = "ey";
var clientSessionTokenPrefix = "seam_cst";
var publishableKeyTokenPrefix = "seam_pk";
var isAccessToken = (token) => token.startsWith(accessTokenPrefix);
var isJwt = (token) => token.startsWith(jwtPrefix);
var isSeamToken = (token) => token.startsWith(tokenPrefix);
var isApiKey = (token) => !isClientSessionToken(token) && !isJwt(token) && !isAccessToken(token) && !isPublishableKey(token) && isSeamToken(token);
var isClientSessionToken = (token) => token.startsWith(clientSessionTokenPrefix);
var isPublishableKey = (token) => token.startsWith(publishableKeyTokenPrefix);
var isConsoleSessionToken = (token) => isJwt(token);
var isPersonalAccessToken = (token) => isAccessToken(token);

// src/lib/seam/connect/auth.ts
var getAuthHeaders = (options) => {
  if ("publishableKey" in options && options.publishableKey != null) {
    return getAuthHeadersForPublishableKey(options.publishableKey);
  }
  if (isSeamHttpOptionsWithApiKey(options)) {
    return getAuthHeadersForApiKey(options);
  }
  if (isSeamHttpOptionsWithClientSessionToken(options)) {
    return getAuthHeadersForClientSessionToken(options);
  }
  if (isSeamHttpWithoutWorkspaceOptionsWithConsoleSessionToken(options) || isSeamHttpOptionsWithConsoleSessionToken(options)) {
    return getAuthHeadersForConsoleSessionToken(options);
  }
  if (isSeamHttpWithoutWorkspaceOptionsWithPersonalAccessToken(options) || isSeamHttpOptionsWithPersonalAccessToken(options)) {
    return getAuthHeadersForPersonalAccessToken(options);
  }
  throw new SeamHttpInvalidOptionsError(
    [
      "Must specify",
      "an apiKey,",
      "clientSessionToken,",
      "publishableKey,",
      "consoleSessionToken",
      "or personalAccessToken.",
      "Attempted reading configuration from the environment, but the environment variable SEAM_API_KEY is not set."
    ].join(" ")
  );
};
var getAuthHeadersForApiKey = ({
  apiKey
}) => {
  if (isClientSessionToken(apiKey)) {
    throw new SeamHttpInvalidTokenError(
      "A Client Session Token cannot be used as an apiKey"
    );
  }
  if (isJwt(apiKey)) {
    throw new SeamHttpInvalidTokenError("A JWT cannot be used as an apiKey");
  }
  if (isAccessToken(apiKey)) {
    throw new SeamHttpInvalidTokenError(
      "An Access Token cannot be used as an apiKey"
    );
  }
  if (isPublishableKey(apiKey)) {
    throw new SeamHttpInvalidTokenError(
      "A Publishable Key cannot be used as an apiKey"
    );
  }
  if (!isSeamToken(apiKey)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid apiKey format, expected token to start with ${tokenPrefix}`
    );
  }
  return {
    authorization: `Bearer ${apiKey}`
  };
};
var getAuthHeadersForClientSessionToken = ({
  clientSessionToken
}) => {
  if (isJwt(clientSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "A JWT cannot be used as a clientSessionToken"
    );
  }
  if (isAccessToken(clientSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "An Access Token cannot be used as a clientSessionToken"
    );
  }
  if (isPublishableKey(clientSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Publishable Key cannot be used as a clientSessionToken"
    );
  }
  if (!isClientSessionToken(clientSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid clientSessionToken format, expected token to start with ${clientSessionTokenPrefix}`
    );
  }
  return {
    authorization: `Bearer ${clientSessionToken}`,
    "client-session-token": clientSessionToken
  };
};
var getAuthHeadersForConsoleSessionToken = ({
  consoleSessionToken,
  ...options
}) => {
  const workspaceId = "workspaceId" in options ? options.workspaceId : void 0;
  if (isAccessToken(consoleSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "An Access Token cannot be used as a consoleSessionToken"
    );
  }
  if (isClientSessionToken(consoleSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Client Session Token cannot be used as a consoleSessionToken"
    );
  }
  if (isPublishableKey(consoleSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Publishable Key cannot be used as a consoleSessionToken"
    );
  }
  if (!isJwt(consoleSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid consoleSessionToken format, expected a JWT which starts with ${jwtPrefix}`
    );
  }
  return {
    authorization: `Bearer ${consoleSessionToken}`,
    ...workspaceId != null ? { "seam-workspace": workspaceId } : {}
  };
};
var getAuthHeadersForPersonalAccessToken = ({
  personalAccessToken,
  ...options
}) => {
  const workspaceId = "workspaceId" in options ? options.workspaceId : void 0;
  if (isJwt(personalAccessToken)) {
    throw new SeamHttpInvalidTokenError(
      "A JWT cannot be used as a personalAccessToken"
    );
  }
  if (isClientSessionToken(personalAccessToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Client Session Token cannot be used as a personalAccessToken"
    );
  }
  if (isPublishableKey(personalAccessToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Publishable Key cannot be used as a personalAccessToken"
    );
  }
  if (!isAccessToken(personalAccessToken)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid personalAccessToken format, expected token to start with ${accessTokenPrefix}`
    );
  }
  return {
    authorization: `Bearer ${personalAccessToken}`,
    ...workspaceId != null ? { "seam-workspace": workspaceId } : {}
  };
};
var getAuthHeadersForPublishableKey = (publishableKey) => {
  if (isJwt(publishableKey)) {
    throw new SeamHttpInvalidTokenError(
      "A JWT cannot be used as a publishableKey"
    );
  }
  if (isAccessToken(publishableKey)) {
    throw new SeamHttpInvalidTokenError(
      "An Access Token cannot be used as a publishableKey"
    );
  }
  if (isClientSessionToken(publishableKey)) {
    throw new SeamHttpInvalidTokenError(
      "A Client Session Token Key cannot be used as a publishableKey"
    );
  }
  if (!isPublishableKey(publishableKey)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid publishableKey format, expected token to start with ${publishableKeyTokenPrefix}`
    );
  }
  return {
    "seam-publishable-key": publishableKey
  };
};
var SeamHttpInvalidTokenError = class extends Error {
  constructor(message) {
    super(`SeamHttp received an invalid token: ${message}`);
    this.name = this.constructor.name;
  }
};
var warnOnInsecureuserIdentifierKey = (userIdentifierKey) => {
  if (isEmail(userIdentifierKey)) {
    console.warn(
      ...[
        "Using an email for the userIdentifierKey is insecure and may return an error in the future!",
        "This is insecure because an email is common knowledge or easily guessed.",
        "Use something with sufficient entropy known only to the owner of the client session.",
        "For help choosing a user identifier key see",
        "https://docs.seam.co/latest/seam-components/overview/get-started-with-client-side-components#3-select-a-user-identifier-key"
      ]
    );
  }
};
var isEmail = (value) => {
  if (value.includes("!")) return false;
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
};

// src/lib/seam/connect/seam-http-error.ts
var SeamHttpApiError = class extends Error {
  code;
  statusCode;
  requestId;
  data;
  constructor(error, statusCode, requestId) {
    const { type, message, data } = error;
    super(message);
    this.name = this.constructor.name;
    this.code = type;
    this.statusCode = statusCode;
    this.requestId = requestId;
    if (data != null) this.data = data;
  }
};
var isSeamHttpApiError = (error) => {
  return error instanceof SeamHttpApiError;
};
var SeamHttpUnauthorizedError = class extends SeamHttpApiError {
  code;
  statusCode;
  constructor(requestId) {
    const type = "unauthorized";
    const status = 401;
    super({ type, message: "Unauthorized" }, status, requestId);
    this.name = this.constructor.name;
    this.code = type;
    this.statusCode = status;
    this.requestId = requestId;
  }
};
var isSeamHttpUnauthorizedError = (error) => {
  return error instanceof SeamHttpUnauthorizedError;
};
var SeamHttpInvalidInputError = class extends SeamHttpApiError {
  code;
  #validationErrors;
  constructor(error, statusCode, requestId) {
    super(error, statusCode, requestId);
    this.name = this.constructor.name;
    this.code = "invalid_input";
    this.#validationErrors = error.validation_errors ?? {};
  }
  getValidationErrorMessages(paramName) {
    return this.#validationErrors[paramName]?._errors ?? [];
  }
};
var isSeamHttpInvalidInputError = (error) => {
  return error instanceof SeamHttpInvalidInputError;
};

// src/lib/seam/connect/error-interceptor.ts
var errorInterceptor = async (err) => {
  if (!axios.isAxiosError(err)) throw err;
  const { response } = err;
  const status = response?.status;
  const requestId = getRequestId(err);
  if (status == null) throw err;
  if (status === 401) {
    throw new SeamHttpUnauthorizedError(requestId);
  }
  if (!isApiErrorResponse(response)) throw err;
  const { type } = response.data.error;
  const args = [response.data.error, status, requestId];
  if (type === "invalid_input") throw new SeamHttpInvalidInputError(...args);
  throw new SeamHttpApiError(...args);
};
var isApiErrorResponse = (response) => {
  if (response == null) return false;
  const { headers, data } = response;
  if (headers == null) return false;
  const contentType = headers["Content-Type"];
  if (typeof contentType === "string" && !contentType.startsWith("application/json")) {
    return false;
  }
  if (typeof data === "object" && data != null) {
    return "error" in data && typeof data.error === "object" && data.error != null && "type" in data.error && typeof data.error.type === "string" && "message" in data.error && typeof data.error.message === "string";
  }
  return false;
};
var getRequestId = (err) => {
  const headers = err.response?.headers;
  if (headers == null) return "";
  const requestId = headers["seam-request-id"];
  if (requestId == null) return "";
  return requestId;
};
var createClient = (options) => {
  const client = axios__default.default.create({
    paramsSerializer: url_search_params_serializer_star.serializeUrlSearchParams,
    adapter: "fetch",
    ...options.axiosOptions
  });
  axiosRetry__default.default(client, {
    retries: 2,
    retryDelay: axiosRetry.exponentialDelay,
    ...options.axiosRetryOptions
  });
  client.interceptors.response.use(void 0, errorInterceptor);
  return client;
};

// src/lib/seam/connect/openapi.ts
var getOpenapiSchema = async (endpoint = defaultEndpoint) => {
  const client = createClient({
    axiosOptions: {
      baseURL: endpoint,
      headers: sdkHeaders
    }
  });
  const { data } = await client.get("/openapi.json");
  return data;
};

// src/lib/seam/connect/resolve-action-attempt.ts
var resolveActionAttempt = async (actionAttempt, actionAttempts, { timeout = 5e3, pollingInterval = 500 }) => {
  let timeoutRef;
  const timeoutPromise = new Promise(
    (_resolve, reject) => {
      timeoutRef = globalThis.setTimeout(() => {
        reject(new SeamActionAttemptTimeoutError(actionAttempt, timeout));
      }, timeout);
    }
  );
  try {
    return await Promise.race([
      pollActionAttempt(actionAttempt, actionAttempts, { pollingInterval }),
      timeoutPromise
    ]);
  } finally {
    if (timeoutRef != null) globalThis.clearTimeout(timeoutRef);
  }
};
var pollActionAttempt = async (actionAttempt, actionAttempts, options) => {
  if (isSuccessfulActionAttempt(actionAttempt)) {
    return actionAttempt;
  }
  if (isFailedActionAttempt(actionAttempt)) {
    throw new SeamActionAttemptFailedError(actionAttempt);
  }
  await new Promise((resolve) => setTimeout(resolve, options.pollingInterval));
  const nextActionAttempt = await actionAttempts.get({
    action_attempt_id: actionAttempt.action_attempt_id
  });
  return await pollActionAttempt(
    nextActionAttempt,
    actionAttempts,
    options
  );
};
var isSeamActionAttemptError = (error) => {
  return error instanceof SeamActionAttemptError;
};
var SeamActionAttemptError = class extends Error {
  actionAttempt;
  constructor(message, actionAttempt) {
    super(message);
    this.name = this.constructor.name;
    this.actionAttempt = actionAttempt;
  }
};
var isSeamActionAttemptFailedError = (error) => {
  return error instanceof SeamActionAttemptFailedError;
};
var SeamActionAttemptFailedError = class extends SeamActionAttemptError {
  code;
  constructor(actionAttempt) {
    super(actionAttempt.error.message, actionAttempt);
    this.name = this.constructor.name;
    this.code = actionAttempt.error.type;
  }
};
var isSeamActionAttemptTimeoutError = (error) => {
  return error instanceof SeamActionAttemptTimeoutError;
};
var SeamActionAttemptTimeoutError = class extends SeamActionAttemptError {
  constructor(actionAttempt, timeout) {
    super(
      `Timed out waiting for action action attempt after ${timeout}ms`,
      actionAttempt
    );
    this.name = this.constructor.name;
  }
};
var isSuccessfulActionAttempt = (actionAttempt) => actionAttempt.status === "success";
var isFailedActionAttempt = (actionAttempt) => actionAttempt.status === "error";
var SeamHttpRequest = class {
  [Symbol.toStringTag] = "SeamHttpRequest";
  #parent;
  #config;
  constructor(parent, config) {
    this.#parent = parent;
    this.#config = config;
  }
  get responseKey() {
    return this.#config.responseKey;
  }
  get url() {
    const { client } = this.#parent;
    const serializer = typeof client.defaults.paramsSerializer === "function" ? client.defaults.paramsSerializer : url_search_params_serializer_star.serializeUrlSearchParams;
    const origin = getUrlPrefix(client.defaults.baseURL ?? "");
    const path = this.params == null ? this.pathname : `${this.pathname}?${serializer(this.params)}`;
    return new URL(`${origin}${path}`);
  }
  get pathname() {
    return this.#config.pathname.startsWith("/") ? this.#config.pathname : `/${this.#config.pathname}`;
  }
  get method() {
    return this.#config.method;
  }
  get params() {
    return this.#config.params;
  }
  get body() {
    return this.#config.body;
  }
  async execute() {
    const response = await this.fetchResponse();
    if (this.responseKey === void 0) {
      return void 0;
    }
    const data = response[this.responseKey];
    if (this.responseKey === "action_attempt") {
      const waitForActionAttempt = this.#config.options?.waitForActionAttempt ?? this.#parent.defaults.waitForActionAttempt;
      if (waitForActionAttempt !== false) {
        const actionAttempt = await resolveActionAttempt(
          data,
          SeamHttpActionAttempts.fromClient(this.#parent.client, {
            ...this.#parent.defaults,
            waitForActionAttempt: false
          }),
          typeof waitForActionAttempt === "boolean" ? {} : waitForActionAttempt
        );
        return actionAttempt;
      }
    }
    return data;
  }
  async fetchResponse() {
    const { client } = this.#parent;
    const response = await client.request({
      url: this.pathname,
      method: this.method,
      data: this.body,
      params: this.params
    });
    return response.data;
  }
  async then(onfulfilled, onrejected) {
    return await this.execute().then(onfulfilled, onrejected);
  }
  async catch(onrejected) {
    return await this.execute().catch(onrejected);
  }
  async finally(onfinally) {
    return await this.execute().finally(onfinally);
  }
};
var getUrlPrefix = (input) => {
  if (canParseUrl(input)) {
    const url = new URL(input).toString();
    if (url.endsWith("/")) return url.slice(0, -1);
    return url;
  }
  if (globalThis.location != null) {
    const pathname = input.startsWith("/") ? input : `/${input}`;
    return new URL(`${globalThis.location.origin}${pathname}`).toString();
  }
  throw new Error(
    `Cannot resolve origin from ${input} in a non-browser environment`
  );
};
var canParseUrl = (input) => {
  try {
    return new URL(input) != null;
  } catch {
    return false;
  }
};

// src/lib/seam/connect/seam-paginator.ts
var SeamPaginator = class {
  #request;
  #parent;
  constructor(parent, request) {
    if (request.responseKey == null) {
      throw new Error(
        `The ${request.pathname} endpoint does not support pagination`
      );
    }
    this.#parent = parent;
    this.#request = request;
  }
  async firstPage() {
    return await this.#fetch();
  }
  async nextPage(nextPageCursor) {
    if (nextPageCursor == null) {
      throw new Error("Cannot get the next page with a null nextPageCursor");
    }
    return await this.#fetch(nextPageCursor);
  }
  async #fetch(nextPageCursor) {
    const responseKey = this.#request.responseKey;
    if (responseKey == null) {
      throw new Error("Cannot paginate a response without a responseKey");
    }
    const request = new SeamHttpRequest(this.#parent, {
      pathname: this.#request.pathname,
      method: this.#request.method,
      responseKey,
      params: this.#request.params != null ? { ...this.#request.params, page_cursor: nextPageCursor } : void 0,
      body: this.#request.body != null ? { ...this.#request.body, page_cursor: nextPageCursor } : void 0
    });
    const response = await request.fetchResponse();
    const data = response[responseKey];
    const paginationData = response != null && typeof response === "object" && "pagination" in response ? response.pagination : null;
    const pagination = {
      hasNextPage: paginationData?.has_next_page ?? false,
      nextPageCursor: paginationData?.next_page_cursor ?? null,
      nextPageUrl: paginationData?.next_page_url ?? null
    };
    if (!Array.isArray(data)) {
      throw new Error(
        `Expected an array response for ${String(responseKey)} but got ${String(typeof data)}`
      );
    }
    return [
      data,
      pagination
    ];
  }
  async flattenToArray() {
    const items = [];
    let [current, pagination] = await this.firstPage();
    items.push(...current);
    while (pagination.hasNextPage) {
      [current, pagination] = await this.nextPage(pagination.nextPageCursor);
      items.push(...current);
    }
    return items;
  }
  async *flatten() {
    let [current, pagination] = await this.firstPage();
    for (const item of current) {
      yield item;
    }
    while (pagination.hasNextPage) {
      [current, pagination] = await this.nextPage(pagination.nextPageCursor);
      for (const item of current) {
        yield item;
      }
    }
  }
  async *[Symbol.asyncIterator]() {
    let [current, pagination] = await this.firstPage();
    yield current;
    while (pagination.hasNextPage) {
      [current, pagination] = await this.nextPage(pagination.nextPageCursor);
      yield current;
    }
  }
};

// src/lib/seam/connect/routes/client-sessions/client-sessions.ts
var SeamHttpClientSessions = class _SeamHttpClientSessions {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpClientSessions.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = _SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpClientSessions.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = _SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/client_sessions/create",
      method: "PUT",
      body: parameters,
      responseKey: "client_session",
      options
    });
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/client_sessions/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/client_sessions/get",
      method: "POST",
      body: parameters,
      responseKey: "client_session",
      options
    });
  }
  getOrCreate(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/client_sessions/get_or_create",
      method: "POST",
      body: parameters,
      responseKey: "client_session",
      options
    });
  }
  grantAccess(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/client_sessions/grant_access",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/client_sessions/list",
      method: "POST",
      body: parameters,
      responseKey: "client_sessions",
      options
    });
  }
  revoke(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/client_sessions/revoke",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/access-codes/simulate/simulate.ts
var SeamHttpAccessCodesSimulate = class _SeamHttpAccessCodesSimulate {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAccessCodesSimulate(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAccessCodesSimulate(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAccessCodesSimulate(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAccessCodesSimulate.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAccessCodesSimulate.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodesSimulate(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodesSimulate(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  createUnmanagedAccessCode(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/simulate/create_unmanaged_access_code",
      method: "POST",
      body: parameters,
      responseKey: "access_code",
      options
    });
  }
};

// src/lib/seam/connect/routes/access-codes/unmanaged/unmanaged.ts
var SeamHttpAccessCodesUnmanaged = class _SeamHttpAccessCodesUnmanaged {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAccessCodesUnmanaged.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAccessCodesUnmanaged.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  convertToManaged(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/unmanaged/convert_to_managed",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/unmanaged/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/unmanaged/get",
      method: "POST",
      body: parameters,
      responseKey: "access_code",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/unmanaged/list",
      method: "POST",
      body: parameters,
      responseKey: "access_codes",
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/unmanaged/update",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/access-codes/access-codes.ts
var SeamHttpAccessCodes = class _SeamHttpAccessCodes {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAccessCodes.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAccessCodes.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get simulate() {
    return SeamHttpAccessCodesSimulate.fromClient(this.client, this.defaults);
  }
  get unmanaged() {
    return SeamHttpAccessCodesUnmanaged.fromClient(this.client, this.defaults);
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/create",
      method: "POST",
      body: parameters,
      responseKey: "access_code",
      options
    });
  }
  createMultiple(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/create_multiple",
      method: "PUT",
      body: parameters,
      responseKey: "access_codes",
      options
    });
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  generateCode(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/generate_code",
      method: "POST",
      body: parameters,
      responseKey: "generated_code",
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/get",
      method: "POST",
      body: parameters,
      responseKey: "access_code",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/list",
      method: "POST",
      body: parameters,
      responseKey: "access_codes",
      options
    });
  }
  pullBackupAccessCode(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/pull_backup_access_code",
      method: "POST",
      body: parameters,
      responseKey: "access_code",
      options
    });
  }
  reportDeviceConstraints(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/report_device_constraints",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/update",
      method: "PUT",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  updateMultiple(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_codes/update_multiple",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/access-grants/unmanaged/unmanaged.ts
var SeamHttpAccessGrantsUnmanaged = class _SeamHttpAccessGrantsUnmanaged {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAccessGrantsUnmanaged(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAccessGrantsUnmanaged(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAccessGrantsUnmanaged(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAccessGrantsUnmanaged.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAccessGrantsUnmanaged.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAccessGrantsUnmanaged(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAccessGrantsUnmanaged(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_grants/unmanaged/get",
      method: "POST",
      body: parameters,
      responseKey: "access_grant",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_grants/unmanaged/list",
      method: "POST",
      body: parameters,
      responseKey: "access_grants",
      options
    });
  }
};

// src/lib/seam/connect/routes/access-grants/access-grants.ts
var SeamHttpAccessGrants = class _SeamHttpAccessGrants {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAccessGrants(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAccessGrants(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAccessGrants(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAccessGrants.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAccessGrants.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAccessGrants(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAccessGrants(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get unmanaged() {
    return SeamHttpAccessGrantsUnmanaged.fromClient(this.client, this.defaults);
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_grants/create",
      method: "POST",
      body: parameters,
      responseKey: "access_grant",
      options
    });
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_grants/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_grants/get",
      method: "GET",
      params: parameters,
      responseKey: "access_grant",
      options
    });
  }
  getRelated(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_grants/get_related",
      method: "POST",
      body: parameters,
      responseKey: "batch",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_grants/list",
      method: "POST",
      body: parameters,
      responseKey: "access_grants",
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_grants/update",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/access-methods/unmanaged/unmanaged.ts
var SeamHttpAccessMethodsUnmanaged = class _SeamHttpAccessMethodsUnmanaged {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAccessMethodsUnmanaged(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAccessMethodsUnmanaged(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAccessMethodsUnmanaged(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAccessMethodsUnmanaged.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAccessMethodsUnmanaged.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAccessMethodsUnmanaged(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAccessMethodsUnmanaged(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_methods/unmanaged/get",
      method: "POST",
      body: parameters,
      responseKey: "access_method",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_methods/unmanaged/list",
      method: "POST",
      body: parameters,
      responseKey: "access_methods",
      options
    });
  }
};

// src/lib/seam/connect/routes/access-methods/access-methods.ts
var SeamHttpAccessMethods = class _SeamHttpAccessMethods {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAccessMethods(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAccessMethods(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAccessMethods(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAccessMethods.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAccessMethods.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAccessMethods(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAccessMethods(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get unmanaged() {
    return SeamHttpAccessMethodsUnmanaged.fromClient(this.client, this.defaults);
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_methods/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  encode(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_methods/encode",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_methods/get",
      method: "POST",
      body: parameters,
      responseKey: "access_method",
      options
    });
  }
  getRelated(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_methods/get_related",
      method: "POST",
      body: parameters,
      responseKey: "batch",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/access_methods/list",
      method: "POST",
      body: parameters,
      responseKey: "access_methods",
      options
    });
  }
};

// src/lib/seam/connect/routes/acs/access-groups/unmanaged/unmanaged.ts
var SeamHttpAcsAccessGroupsUnmanaged = class _SeamHttpAcsAccessGroupsUnmanaged {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsAccessGroupsUnmanaged(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsAccessGroupsUnmanaged(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsAccessGroupsUnmanaged(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAcsAccessGroupsUnmanaged.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsAccessGroupsUnmanaged.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsAccessGroupsUnmanaged(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsAccessGroupsUnmanaged(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/acs/access_groups/unmanaged/get",
      method: "POST",
      body: parameters,
      responseKey: "acs_access_group",
      options
    });
  }
  list(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/acs/access_groups/unmanaged/list",
      method: "POST",
      body: parameters,
      responseKey: "acs_access_groups",
      options
    });
  }
};

// src/lib/seam/connect/routes/acs/access-groups/access-groups.ts
var SeamHttpAcsAccessGroups = class _SeamHttpAcsAccessGroups {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAcsAccessGroups.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsAccessGroups.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get unmanaged() {
    return SeamHttpAcsAccessGroupsUnmanaged.fromClient(
      this.client,
      this.defaults
    );
  }
  addUser(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/access_groups/add_user",
      method: "PUT",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/access_groups/get",
      method: "POST",
      body: parameters,
      responseKey: "acs_access_group",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/access_groups/list",
      method: "POST",
      body: parameters,
      responseKey: "acs_access_groups",
      options
    });
  }
  listAccessibleEntrances(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/access_groups/list_accessible_entrances",
      method: "POST",
      body: parameters,
      responseKey: "acs_entrances",
      options
    });
  }
  listUsers(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/access_groups/list_users",
      method: "POST",
      body: parameters,
      responseKey: "acs_users",
      options
    });
  }
  removeUser(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/access_groups/remove_user",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/acs/credential-pools/credential-pools.ts
var SeamHttpAcsCredentialPools = class _SeamHttpAcsCredentialPools {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAcsCredentialPools.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsCredentialPools.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  list(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/acs/credential_pools/list",
      method: "POST",
      body: parameters,
      responseKey: "acs_credential_pools",
      options
    });
  }
};

// src/lib/seam/connect/routes/acs/credential-provisioning-automations/credential-provisioning-automations.ts
var SeamHttpAcsCredentialProvisioningAutomations = class _SeamHttpAcsCredentialProvisioningAutomations {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAcsCredentialProvisioningAutomations.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsCredentialProvisioningAutomations.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  launch(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/acs/credential_provisioning_automations/launch",
      method: "POST",
      body: parameters,
      responseKey: "acs_credential_provisioning_automation",
      options
    });
  }
};

// src/lib/seam/connect/routes/acs/credentials/unmanaged/unmanaged.ts
var SeamHttpAcsCredentialsUnmanaged = class _SeamHttpAcsCredentialsUnmanaged {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsCredentialsUnmanaged(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsCredentialsUnmanaged(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsCredentialsUnmanaged(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAcsCredentialsUnmanaged.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsCredentialsUnmanaged.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialsUnmanaged(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialsUnmanaged(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/acs/credentials/unmanaged/get",
      method: "POST",
      body: parameters,
      responseKey: "acs_credential",
      options
    });
  }
  list(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/acs/credentials/unmanaged/list",
      method: "GET",
      params: parameters,
      responseKey: "acs_credentials",
      options
    });
  }
};

// src/lib/seam/connect/routes/acs/credentials/credentials.ts
var SeamHttpAcsCredentials = class _SeamHttpAcsCredentials {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAcsCredentials.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsCredentials.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get unmanaged() {
    return SeamHttpAcsCredentialsUnmanaged.fromClient(
      this.client,
      this.defaults
    );
  }
  assign(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/credentials/assign",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/credentials/create",
      method: "POST",
      body: parameters,
      responseKey: "acs_credential",
      options
    });
  }
  createOfflineCode(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/acs/credentials/create_offline_code",
      method: "POST",
      body: parameters,
      responseKey: "acs_credential",
      options
    });
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/credentials/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/credentials/get",
      method: "POST",
      body: parameters,
      responseKey: "acs_credential",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/credentials/list",
      method: "GET",
      params: parameters,
      responseKey: "acs_credentials",
      options
    });
  }
  listAccessibleEntrances(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/credentials/list_accessible_entrances",
      method: "POST",
      body: parameters,
      responseKey: "acs_entrances",
      options
    });
  }
  unassign(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/credentials/unassign",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/credentials/update",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/acs/encoders/simulate/simulate.ts
var SeamHttpAcsEncodersSimulate = class _SeamHttpAcsEncodersSimulate {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsEncodersSimulate(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsEncodersSimulate(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsEncodersSimulate(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAcsEncodersSimulate.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsEncodersSimulate.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsEncodersSimulate(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsEncodersSimulate(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  nextCredentialEncodeWillFail(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/encoders/simulate/next_credential_encode_will_fail",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  nextCredentialEncodeWillSucceed(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/encoders/simulate/next_credential_encode_will_succeed",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  nextCredentialScanWillFail(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/encoders/simulate/next_credential_scan_will_fail",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  nextCredentialScanWillSucceed(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/encoders/simulate/next_credential_scan_will_succeed",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/acs/encoders/encoders.ts
var SeamHttpAcsEncoders = class _SeamHttpAcsEncoders {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsEncoders(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsEncoders(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsEncoders(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAcsEncoders.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsEncoders.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsEncoders(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsEncoders(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get simulate() {
    return SeamHttpAcsEncodersSimulate.fromClient(this.client, this.defaults);
  }
  encodeCredential(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/encoders/encode_credential",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/encoders/get",
      method: "POST",
      body: parameters,
      responseKey: "acs_encoder",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/encoders/list",
      method: "GET",
      params: parameters,
      responseKey: "acs_encoders",
      options
    });
  }
  scanCredential(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/encoders/scan_credential",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
};

// src/lib/seam/connect/routes/acs/entrances/entrances.ts
var SeamHttpAcsEntrances = class _SeamHttpAcsEntrances {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAcsEntrances.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsEntrances.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/entrances/get",
      method: "POST",
      body: parameters,
      responseKey: "acs_entrance",
      options
    });
  }
  grantAccess(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/entrances/grant_access",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/entrances/list",
      method: "POST",
      body: parameters,
      responseKey: "acs_entrances",
      options
    });
  }
  listCredentialsWithAccess(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/entrances/list_credentials_with_access",
      method: "POST",
      body: parameters,
      responseKey: "acs_credentials",
      options
    });
  }
};

// src/lib/seam/connect/routes/acs/systems/systems.ts
var SeamHttpAcsSystems = class _SeamHttpAcsSystems {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAcsSystems.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsSystems.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/systems/get",
      method: "POST",
      body: parameters,
      responseKey: "acs_system",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/systems/list",
      method: "POST",
      body: parameters,
      responseKey: "acs_systems",
      options
    });
  }
  listCompatibleCredentialManagerAcsSystems(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/systems/list_compatible_credential_manager_acs_systems",
      method: "POST",
      body: parameters,
      responseKey: "acs_systems",
      options
    });
  }
};

// src/lib/seam/connect/routes/acs/users/unmanaged/unmanaged.ts
var SeamHttpAcsUsersUnmanaged = class _SeamHttpAcsUsersUnmanaged {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsUsersUnmanaged(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsUsersUnmanaged(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsUsersUnmanaged(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAcsUsersUnmanaged.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsUsersUnmanaged.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsUsersUnmanaged(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsUsersUnmanaged(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/acs/users/unmanaged/get",
      method: "POST",
      body: parameters,
      responseKey: "acs_user",
      options
    });
  }
  list(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/acs/users/unmanaged/list",
      method: "POST",
      body: parameters,
      responseKey: "acs_users",
      options
    });
  }
};

// src/lib/seam/connect/routes/acs/users/users.ts
var SeamHttpAcsUsers = class _SeamHttpAcsUsers {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAcsUsers.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsUsers.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get unmanaged() {
    return SeamHttpAcsUsersUnmanaged.fromClient(this.client, this.defaults);
  }
  addToAccessGroup(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/users/add_to_access_group",
      method: "PUT",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/users/create",
      method: "POST",
      body: parameters,
      responseKey: "acs_user",
      options
    });
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/users/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/users/get",
      method: "POST",
      body: parameters,
      responseKey: "acs_user",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/users/list",
      method: "POST",
      body: parameters,
      responseKey: "acs_users",
      options
    });
  }
  listAccessibleEntrances(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/users/list_accessible_entrances",
      method: "POST",
      body: parameters,
      responseKey: "acs_entrances",
      options
    });
  }
  removeFromAccessGroup(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/users/remove_from_access_group",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  revokeAccessToAllEntrances(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/users/revoke_access_to_all_entrances",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  suspend(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/users/suspend",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  unsuspend(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/users/unsuspend",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/acs/users/update",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/acs/acs.ts
var SeamHttpAcs = class _SeamHttpAcs {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpAcs.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcs.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get accessGroups() {
    return SeamHttpAcsAccessGroups.fromClient(this.client, this.defaults);
  }
  get credentialPools() {
    return SeamHttpAcsCredentialPools.fromClient(this.client, this.defaults);
  }
  get credentialProvisioningAutomations() {
    return SeamHttpAcsCredentialProvisioningAutomations.fromClient(
      this.client,
      this.defaults
    );
  }
  get credentials() {
    return SeamHttpAcsCredentials.fromClient(this.client, this.defaults);
  }
  get encoders() {
    return SeamHttpAcsEncoders.fromClient(this.client, this.defaults);
  }
  get entrances() {
    return SeamHttpAcsEntrances.fromClient(this.client, this.defaults);
  }
  get systems() {
    return SeamHttpAcsSystems.fromClient(this.client, this.defaults);
  }
  get users() {
    return SeamHttpAcsUsers.fromClient(this.client, this.defaults);
  }
};

// src/lib/seam/connect/routes/action-attempts/action-attempts.ts
var SeamHttpActionAttempts = class _SeamHttpActionAttempts {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpActionAttempts.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpActionAttempts.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/action_attempts/get",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/action_attempts/list",
      method: "POST",
      body: parameters,
      responseKey: "action_attempts",
      options
    });
  }
};

// src/lib/seam/connect/routes/bridges/bridges.ts
var SeamHttpBridges = class _SeamHttpBridges {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpBridges(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpBridges(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpBridges(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpBridges.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpBridges.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpBridges(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpBridges(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/bridges/get",
      method: "POST",
      body: parameters,
      responseKey: "bridge",
      options
    });
  }
  list(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/bridges/list",
      method: "POST",
      body: parameters,
      responseKey: "bridges",
      options
    });
  }
};

// src/lib/seam/connect/routes/connect-webviews/connect-webviews.ts
var SeamHttpConnectWebviews = class _SeamHttpConnectWebviews {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpConnectWebviews.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpConnectWebviews.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/connect_webviews/create",
      method: "POST",
      body: parameters,
      responseKey: "connect_webview",
      options
    });
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/connect_webviews/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/connect_webviews/get",
      method: "POST",
      body: parameters,
      responseKey: "connect_webview",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/connect_webviews/list",
      method: "POST",
      body: parameters,
      responseKey: "connect_webviews",
      options
    });
  }
};

// src/lib/seam/connect/routes/connected-accounts/connected-accounts.ts
var SeamHttpConnectedAccounts = class _SeamHttpConnectedAccounts {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpConnectedAccounts.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpConnectedAccounts.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/connected_accounts/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/connected_accounts/get",
      method: "GET",
      params: parameters,
      responseKey: "connected_account",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/connected_accounts/list",
      method: "POST",
      body: parameters,
      responseKey: "connected_accounts",
      options
    });
  }
  sync(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/connected_accounts/sync",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/connected_accounts/update",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/customers/customers.ts
var SeamHttpCustomers = class _SeamHttpCustomers {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpCustomers(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpCustomers(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpCustomers(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpCustomers.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpCustomers.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpCustomers(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpCustomers(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  createPortal(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/customers/create_portal",
      method: "POST",
      body: parameters,
      responseKey: "magic_link",
      options
    });
  }
  deleteData(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/customers/delete_data",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  pushData(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/customers/push_data",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/devices/simulate/simulate.ts
var SeamHttpDevicesSimulate = class _SeamHttpDevicesSimulate {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpDevicesSimulate(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpDevicesSimulate(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpDevicesSimulate(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpDevicesSimulate.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpDevicesSimulate.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpDevicesSimulate(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpDevicesSimulate(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  connect(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/devices/simulate/connect",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  connectToHub(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/devices/simulate/connect_to_hub",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  disconnect(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/devices/simulate/disconnect",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  disconnectFromHub(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/devices/simulate/disconnect_from_hub",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  paidSubscription(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/devices/simulate/paid_subscription",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  remove(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/devices/simulate/remove",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/devices/unmanaged/unmanaged.ts
var SeamHttpDevicesUnmanaged = class _SeamHttpDevicesUnmanaged {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpDevicesUnmanaged.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpDevicesUnmanaged.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/devices/unmanaged/get",
      method: "POST",
      body: parameters,
      responseKey: "device",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/devices/unmanaged/list",
      method: "POST",
      body: parameters,
      responseKey: "devices",
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/devices/unmanaged/update",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/devices/devices.ts
var SeamHttpDevices = class _SeamHttpDevices {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpDevices.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpDevices.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get simulate() {
    return SeamHttpDevicesSimulate.fromClient(this.client, this.defaults);
  }
  get unmanaged() {
    return SeamHttpDevicesUnmanaged.fromClient(this.client, this.defaults);
  }
  delete(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/devices/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/devices/get",
      method: "POST",
      body: parameters,
      responseKey: "device",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/devices/list",
      method: "POST",
      body: parameters,
      responseKey: "devices",
      options
    });
  }
  listDeviceProviders(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/devices/list_device_providers",
      method: "POST",
      body: parameters,
      responseKey: "device_providers",
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/devices/update",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/events/events.ts
var SeamHttpEvents = class _SeamHttpEvents {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpEvents.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpEvents.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/events/get",
      method: "POST",
      body: parameters,
      responseKey: "event",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/events/list",
      method: "POST",
      body: parameters,
      responseKey: "events",
      options
    });
  }
};

// src/lib/seam/connect/routes/instant-keys/instant-keys.ts
var SeamHttpInstantKeys = class _SeamHttpInstantKeys {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpInstantKeys(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpInstantKeys(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpInstantKeys(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpInstantKeys.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpInstantKeys.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpInstantKeys(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpInstantKeys(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/instant_keys/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/instant_keys/get",
      method: "POST",
      body: parameters,
      responseKey: "instant_key",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/instant_keys/list",
      method: "POST",
      body: parameters,
      responseKey: "instant_keys",
      options
    });
  }
};

// src/lib/seam/connect/routes/locks/simulate/simulate.ts
var SeamHttpLocksSimulate = class _SeamHttpLocksSimulate {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpLocksSimulate(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpLocksSimulate(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpLocksSimulate(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpLocksSimulate.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpLocksSimulate.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpLocksSimulate(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpLocksSimulate(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  keypadCodeEntry(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/locks/simulate/keypad_code_entry",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
  manualLockViaKeypad(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/locks/simulate/manual_lock_via_keypad",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
};

// src/lib/seam/connect/routes/locks/locks.ts
var SeamHttpLocks = class _SeamHttpLocks {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpLocks.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpLocks.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get simulate() {
    return SeamHttpLocksSimulate.fromClient(this.client, this.defaults);
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/locks/get",
      method: "POST",
      body: parameters,
      responseKey: "device",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/locks/list",
      method: "POST",
      body: parameters,
      responseKey: "devices",
      options
    });
  }
  lockDoor(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/locks/lock_door",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
  unlockDoor(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/locks/unlock_door",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
};

// src/lib/seam/connect/routes/noise-sensors/noise-thresholds/noise-thresholds.ts
var SeamHttpNoiseSensorsNoiseThresholds = class _SeamHttpNoiseSensorsNoiseThresholds {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpNoiseSensorsNoiseThresholds.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpNoiseSensorsNoiseThresholds.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/noise_sensors/noise_thresholds/create",
      method: "POST",
      body: parameters,
      responseKey: "noise_threshold",
      options
    });
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/noise_sensors/noise_thresholds/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/noise_sensors/noise_thresholds/get",
      method: "POST",
      body: parameters,
      responseKey: "noise_threshold",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/noise_sensors/noise_thresholds/list",
      method: "POST",
      body: parameters,
      responseKey: "noise_thresholds",
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/noise_sensors/noise_thresholds/update",
      method: "PUT",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/noise-sensors/simulate/simulate.ts
var SeamHttpNoiseSensorsSimulate = class _SeamHttpNoiseSensorsSimulate {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpNoiseSensorsSimulate(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpNoiseSensorsSimulate(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpNoiseSensorsSimulate(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpNoiseSensorsSimulate.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpNoiseSensorsSimulate.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensorsSimulate(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensorsSimulate(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  triggerNoiseThreshold(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/noise_sensors/simulate/trigger_noise_threshold",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/noise-sensors/noise-sensors.ts
var SeamHttpNoiseSensors = class _SeamHttpNoiseSensors {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpNoiseSensors.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpNoiseSensors.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get noiseThresholds() {
    return SeamHttpNoiseSensorsNoiseThresholds.fromClient(
      this.client,
      this.defaults
    );
  }
  get simulate() {
    return SeamHttpNoiseSensorsSimulate.fromClient(this.client, this.defaults);
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/noise_sensors/list",
      method: "POST",
      body: parameters,
      responseKey: "devices",
      options
    });
  }
};

// src/lib/seam/connect/routes/phones/simulate/simulate.ts
var SeamHttpPhonesSimulate = class _SeamHttpPhonesSimulate {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpPhonesSimulate(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpPhonesSimulate(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpPhonesSimulate(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpPhonesSimulate.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpPhonesSimulate.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpPhonesSimulate(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpPhonesSimulate(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  createSandboxPhone(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/phones/simulate/create_sandbox_phone",
      method: "POST",
      body: parameters,
      responseKey: "phone",
      options
    });
  }
};

// src/lib/seam/connect/routes/phones/phones.ts
var SeamHttpPhones = class _SeamHttpPhones {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpPhones.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpPhones.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get simulate() {
    return SeamHttpPhonesSimulate.fromClient(this.client, this.defaults);
  }
  deactivate(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/phones/deactivate",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/phones/get",
      method: "POST",
      body: parameters,
      responseKey: "phone",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/phones/list",
      method: "POST",
      body: parameters,
      responseKey: "phones",
      options
    });
  }
};

// src/lib/seam/connect/routes/seam/console/v1/timelines/timelines.ts
var SeamHttpSeamConsoleV1Timelines = class _SeamHttpSeamConsoleV1Timelines {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSeamConsoleV1Timelines(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSeamConsoleV1Timelines(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSeamConsoleV1Timelines(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSeamConsoleV1Timelines.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSeamConsoleV1Timelines.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSeamConsoleV1Timelines(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSeamConsoleV1Timelines(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/seam/console/v1/timelines/get",
      method: "POST",
      body: parameters,
      responseKey: "timeline",
      options
    });
  }
};

// src/lib/seam/connect/routes/seam/console/v1/v1.ts
var SeamHttpSeamConsoleV1 = class _SeamHttpSeamConsoleV1 {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSeamConsoleV1(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSeamConsoleV1(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSeamConsoleV1(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSeamConsoleV1.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSeamConsoleV1.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSeamConsoleV1(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSeamConsoleV1(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get timelines() {
    return SeamHttpSeamConsoleV1Timelines.fromClient(this.client, this.defaults);
  }
  getResourceLocator(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/seam/console/v1/get_resource_locator",
      method: "GET",
      params: parameters,
      responseKey: "resource_locator",
      options
    });
  }
};

// src/lib/seam/connect/routes/seam/console/console.ts
var SeamHttpSeamConsole = class _SeamHttpSeamConsole {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSeamConsole(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSeamConsole(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSeamConsole(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSeamConsole.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSeamConsole.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSeamConsole(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSeamConsole(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get v1() {
    return SeamHttpSeamConsoleV1.fromClient(this.client, this.defaults);
  }
};

// src/lib/seam/connect/routes/seam/customer/v1/automation-runs/automation-runs.ts
var SeamHttpSeamCustomerV1AutomationRuns = class _SeamHttpSeamCustomerV1AutomationRuns {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSeamCustomerV1AutomationRuns(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSeamCustomerV1AutomationRuns(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSeamCustomerV1AutomationRuns(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSeamCustomerV1AutomationRuns.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSeamCustomerV1AutomationRuns.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1AutomationRuns(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1AutomationRuns(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  list(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/seam/customer/v1/automation_runs/list",
      method: "POST",
      body: parameters,
      responseKey: "automation_runs",
      options
    });
  }
};

// src/lib/seam/connect/routes/seam/customer/v1/automations/automations.ts
var SeamHttpSeamCustomerV1Automations = class _SeamHttpSeamCustomerV1Automations {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSeamCustomerV1Automations(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSeamCustomerV1Automations(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSeamCustomerV1Automations(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSeamCustomerV1Automations.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSeamCustomerV1Automations.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1Automations(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1Automations(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  delete(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/seam/customer/v1/automations/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/seam/customer/v1/automations/get",
      method: "GET",
      params: parameters,
      responseKey: void 0,
      options
    });
  }
  update(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/seam/customer/v1/automations/update",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/seam/customer/v1/events/events.ts
var SeamHttpSeamCustomerV1Events = class _SeamHttpSeamCustomerV1Events {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSeamCustomerV1Events(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSeamCustomerV1Events(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSeamCustomerV1Events(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSeamCustomerV1Events.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSeamCustomerV1Events.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1Events(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1Events(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  list(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/seam/customer/v1/events/list",
      method: "POST",
      body: parameters,
      responseKey: "events",
      options
    });
  }
};

// src/lib/seam/connect/routes/seam/customer/v1/portals/portals.ts
var SeamHttpSeamCustomerV1Portals = class _SeamHttpSeamCustomerV1Portals {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSeamCustomerV1Portals(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSeamCustomerV1Portals(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSeamCustomerV1Portals(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSeamCustomerV1Portals.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSeamCustomerV1Portals.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1Portals(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1Portals(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/seam/customer/v1/portals/get",
      method: "POST",
      body: parameters,
      responseKey: "customer_portal",
      options
    });
  }
};

// src/lib/seam/connect/routes/seam/customer/v1/reservations/reservations.ts
var SeamHttpSeamCustomerV1Reservations = class _SeamHttpSeamCustomerV1Reservations {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSeamCustomerV1Reservations(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSeamCustomerV1Reservations(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSeamCustomerV1Reservations(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSeamCustomerV1Reservations.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSeamCustomerV1Reservations.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1Reservations(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1Reservations(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/seam/customer/v1/reservations/get",
      method: "POST",
      body: parameters,
      responseKey: "reservation",
      options
    });
  }
  list(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/seam/customer/v1/reservations/list",
      method: "POST",
      body: parameters,
      responseKey: "reservations",
      options
    });
  }
};

// src/lib/seam/connect/routes/seam/customer/v1/settings/settings.ts
var SeamHttpSeamCustomerV1Settings = class _SeamHttpSeamCustomerV1Settings {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSeamCustomerV1Settings(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSeamCustomerV1Settings(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSeamCustomerV1Settings(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSeamCustomerV1Settings.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSeamCustomerV1Settings.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1Settings(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1Settings(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/seam/customer/v1/settings/get",
      method: "GET",
      params: parameters,
      responseKey: "business_vertical",
      options
    });
  }
  update(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/seam/customer/v1/settings/update",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/seam/customer/v1/spaces/spaces.ts
var SeamHttpSeamCustomerV1Spaces = class _SeamHttpSeamCustomerV1Spaces {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSeamCustomerV1Spaces(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSeamCustomerV1Spaces(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSeamCustomerV1Spaces(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSeamCustomerV1Spaces.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSeamCustomerV1Spaces.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1Spaces(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1Spaces(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/seam/customer/v1/spaces/create",
      method: "POST",
      body: parameters,
      responseKey: "space",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/seam/customer/v1/spaces/list",
      method: "POST",
      body: parameters,
      responseKey: "spaces",
      options
    });
  }
};

// src/lib/seam/connect/routes/seam/customer/v1/v1.ts
var SeamHttpSeamCustomerV1 = class _SeamHttpSeamCustomerV1 {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSeamCustomerV1(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSeamCustomerV1(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSeamCustomerV1(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSeamCustomerV1.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSeamCustomerV1.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSeamCustomerV1(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get automationRuns() {
    return SeamHttpSeamCustomerV1AutomationRuns.fromClient(
      this.client,
      this.defaults
    );
  }
  get automations() {
    return SeamHttpSeamCustomerV1Automations.fromClient(
      this.client,
      this.defaults
    );
  }
  get events() {
    return SeamHttpSeamCustomerV1Events.fromClient(this.client, this.defaults);
  }
  get portals() {
    return SeamHttpSeamCustomerV1Portals.fromClient(this.client, this.defaults);
  }
  get reservations() {
    return SeamHttpSeamCustomerV1Reservations.fromClient(
      this.client,
      this.defaults
    );
  }
  get settings() {
    return SeamHttpSeamCustomerV1Settings.fromClient(this.client, this.defaults);
  }
  get spaces() {
    return SeamHttpSeamCustomerV1Spaces.fromClient(this.client, this.defaults);
  }
};

// src/lib/seam/connect/routes/seam/partner/v1/building-blocks/spaces/spaces.ts
var SeamHttpSeamPartnerV1BuildingBlocksSpaces = class _SeamHttpSeamPartnerV1BuildingBlocksSpaces {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSeamPartnerV1BuildingBlocksSpaces(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSeamPartnerV1BuildingBlocksSpaces(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSeamPartnerV1BuildingBlocksSpaces(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSeamPartnerV1BuildingBlocksSpaces.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSeamPartnerV1BuildingBlocksSpaces.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSeamPartnerV1BuildingBlocksSpaces(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSeamPartnerV1BuildingBlocksSpaces(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  autoMap(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/seam/partner/v1/building_blocks/spaces/auto_map",
      method: "POST",
      body: parameters,
      responseKey: "spaces",
      options
    });
  }
};

// src/lib/seam/connect/routes/seam/partner/v1/building-blocks/building-blocks.ts
var SeamHttpSeamPartnerV1BuildingBlocks = class _SeamHttpSeamPartnerV1BuildingBlocks {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSeamPartnerV1BuildingBlocks(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSeamPartnerV1BuildingBlocks(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSeamPartnerV1BuildingBlocks(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSeamPartnerV1BuildingBlocks.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSeamPartnerV1BuildingBlocks.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSeamPartnerV1BuildingBlocks(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSeamPartnerV1BuildingBlocks(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get spaces() {
    return SeamHttpSeamPartnerV1BuildingBlocksSpaces.fromClient(
      this.client,
      this.defaults
    );
  }
};

// src/lib/seam/connect/routes/spaces/spaces.ts
var SeamHttpSpaces = class _SeamHttpSpaces {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpSpaces(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpSpaces(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpSpaces(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpSpaces.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpSpaces.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpSpaces(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpSpaces(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  addAcsEntrances(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/spaces/add_acs_entrances",
      method: "PUT",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  addDevices(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/spaces/add_devices",
      method: "PUT",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/spaces/create",
      method: "POST",
      body: parameters,
      responseKey: "space",
      options
    });
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/spaces/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/spaces/get",
      method: "GET",
      params: parameters,
      responseKey: "space",
      options
    });
  }
  getRelated(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/spaces/get_related",
      method: "POST",
      body: parameters,
      responseKey: "batch",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/spaces/list",
      method: "POST",
      body: parameters,
      responseKey: "spaces",
      options
    });
  }
  removeAcsEntrances(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/spaces/remove_acs_entrances",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  removeDevices(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/spaces/remove_devices",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/spaces/update",
      method: "PATCH",
      body: parameters,
      responseKey: "space",
      options
    });
  }
};

// src/lib/seam/connect/routes/thermostats/daily-programs/daily-programs.ts
var SeamHttpThermostatsDailyPrograms = class _SeamHttpThermostatsDailyPrograms {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpThermostatsDailyPrograms(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpThermostatsDailyPrograms(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpThermostatsDailyPrograms(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpThermostatsDailyPrograms.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpThermostatsDailyPrograms.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpThermostatsDailyPrograms(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpThermostatsDailyPrograms(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/daily_programs/create",
      method: "POST",
      body: parameters,
      responseKey: "thermostat_daily_program",
      options
    });
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/daily_programs/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/daily_programs/update",
      method: "PATCH",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
};

// src/lib/seam/connect/routes/thermostats/schedules/schedules.ts
var SeamHttpThermostatsSchedules = class _SeamHttpThermostatsSchedules {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpThermostatsSchedules(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpThermostatsSchedules(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpThermostatsSchedules(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpThermostatsSchedules.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpThermostatsSchedules.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpThermostatsSchedules(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpThermostatsSchedules(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/schedules/create",
      method: "POST",
      body: parameters,
      responseKey: "thermostat_schedule",
      options
    });
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/schedules/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/schedules/get",
      method: "POST",
      body: parameters,
      responseKey: "thermostat_schedule",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/schedules/list",
      method: "POST",
      body: parameters,
      responseKey: "thermostat_schedules",
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/schedules/update",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/thermostats/simulate/simulate.ts
var SeamHttpThermostatsSimulate = class _SeamHttpThermostatsSimulate {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpThermostatsSimulate(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpThermostatsSimulate(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpThermostatsSimulate(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpThermostatsSimulate.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpThermostatsSimulate.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpThermostatsSimulate(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpThermostatsSimulate(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  hvacModeAdjusted(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/simulate/hvac_mode_adjusted",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  temperatureReached(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/simulate/temperature_reached",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/thermostats/thermostats.ts
var SeamHttpThermostats = class _SeamHttpThermostats {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpThermostats.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpThermostats.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get dailyPrograms() {
    return SeamHttpThermostatsDailyPrograms.fromClient(
      this.client,
      this.defaults
    );
  }
  get schedules() {
    return SeamHttpThermostatsSchedules.fromClient(this.client, this.defaults);
  }
  get simulate() {
    return SeamHttpThermostatsSimulate.fromClient(this.client, this.defaults);
  }
  activateClimatePreset(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/activate_climate_preset",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
  cool(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/cool",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
  createClimatePreset(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/create_climate_preset",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  deleteClimatePreset(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/delete_climate_preset",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/get",
      method: "POST",
      body: parameters,
      responseKey: "thermostat",
      options
    });
  }
  heat(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/heat",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
  heatCool(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/heat_cool",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/list",
      method: "POST",
      body: parameters,
      responseKey: "devices",
      options
    });
  }
  off(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/off",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
  setFallbackClimatePreset(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/set_fallback_climate_preset",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  setFanMode(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/set_fan_mode",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
  setHvacMode(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/set_hvac_mode",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
  setTemperatureThreshold(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/set_temperature_threshold",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  updateClimatePreset(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/update_climate_preset",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  updateWeeklyProgram(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/thermostats/update_weekly_program",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
};

// src/lib/seam/connect/routes/unstable-partner/building-blocks/building-blocks.ts
var SeamHttpUnstablePartnerBuildingBlocks = class _SeamHttpUnstablePartnerBuildingBlocks {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpUnstablePartnerBuildingBlocks(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpUnstablePartnerBuildingBlocks(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpUnstablePartnerBuildingBlocks(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpUnstablePartnerBuildingBlocks.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpUnstablePartnerBuildingBlocks.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpUnstablePartnerBuildingBlocks(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpUnstablePartnerBuildingBlocks(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  connectAccounts(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/unstable_partner/building_blocks/connect_accounts",
      method: "POST",
      body: parameters,
      responseKey: "magic_link",
      options
    });
  }
  generateMagicLink(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/unstable_partner/building_blocks/generate_magic_link",
      method: "POST",
      body: parameters,
      responseKey: "magic_link",
      options
    });
  }
  manageDevices(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/unstable_partner/building_blocks/manage_devices",
      method: "POST",
      body: parameters,
      responseKey: "magic_link",
      options
    });
  }
  organizeSpaces(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/unstable_partner/building_blocks/organize_spaces",
      method: "POST",
      body: parameters,
      responseKey: "magic_link",
      options
    });
  }
};

// src/lib/seam/connect/routes/unstable-partner/unstable-partner.ts
var SeamHttpUnstablePartner = class _SeamHttpUnstablePartner {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpUnstablePartner(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpUnstablePartner(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpUnstablePartner(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpUnstablePartner.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpUnstablePartner.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpUnstablePartner(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpUnstablePartner(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get buildingBlocks() {
    return SeamHttpUnstablePartnerBuildingBlocks.fromClient(
      this.client,
      this.defaults
    );
  }
};

// src/lib/seam/connect/routes/user-identities/enrollment-automations/enrollment-automations.ts
var SeamHttpUserIdentitiesEnrollmentAutomations = class _SeamHttpUserIdentitiesEnrollmentAutomations {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpUserIdentitiesEnrollmentAutomations.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpUserIdentitiesEnrollmentAutomations.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  delete(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/enrollment_automations/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/enrollment_automations/get",
      method: "POST",
      body: parameters,
      responseKey: "enrollment_automation",
      options
    });
  }
  launch(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/enrollment_automations/launch",
      method: "POST",
      body: parameters,
      responseKey: "enrollment_automation",
      options
    });
  }
  list(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/enrollment_automations/list",
      method: "POST",
      body: parameters,
      responseKey: "enrollment_automations",
      options
    });
  }
};

// src/lib/seam/connect/routes/user-identities/unmanaged/unmanaged.ts
var SeamHttpUserIdentitiesUnmanaged = class _SeamHttpUserIdentitiesUnmanaged {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpUserIdentitiesUnmanaged(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpUserIdentitiesUnmanaged(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpUserIdentitiesUnmanaged(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpUserIdentitiesUnmanaged.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpUserIdentitiesUnmanaged.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentitiesUnmanaged(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentitiesUnmanaged(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/unmanaged/get",
      method: "POST",
      body: parameters,
      responseKey: "user_identity",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/unmanaged/list",
      method: "POST",
      body: parameters,
      responseKey: "user_identities",
      options
    });
  }
};

// src/lib/seam/connect/routes/user-identities/user-identities.ts
var SeamHttpUserIdentities = class _SeamHttpUserIdentities {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpUserIdentities.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpUserIdentities.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get enrollmentAutomations() {
    return SeamHttpUserIdentitiesEnrollmentAutomations.fromClient(
      this.client,
      this.defaults
    );
  }
  get unmanaged() {
    return SeamHttpUserIdentitiesUnmanaged.fromClient(
      this.client,
      this.defaults
    );
  }
  addAcsUser(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/add_acs_user",
      method: "PUT",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/create",
      method: "POST",
      body: parameters,
      responseKey: "user_identity",
      options
    });
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  generateInstantKey(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/generate_instant_key",
      method: "POST",
      body: parameters,
      responseKey: "instant_key",
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/get",
      method: "GET",
      params: parameters,
      responseKey: "user_identity",
      options
    });
  }
  grantAccessToDevice(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/grant_access_to_device",
      method: "PUT",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/list",
      method: "POST",
      body: parameters,
      responseKey: "user_identities",
      options
    });
  }
  listAccessibleDevices(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/list_accessible_devices",
      method: "POST",
      body: parameters,
      responseKey: "devices",
      options
    });
  }
  listAcsSystems(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/list_acs_systems",
      method: "POST",
      body: parameters,
      responseKey: "acs_systems",
      options
    });
  }
  listAcsUsers(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/list_acs_users",
      method: "POST",
      body: parameters,
      responseKey: "acs_users",
      options
    });
  }
  removeAcsUser(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/remove_acs_user",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  revokeAccessToDevice(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/revoke_access_to_device",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/user_identities/update",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/webhooks/webhooks.ts
var SeamHttpWebhooks = class _SeamHttpWebhooks {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpWebhooks.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpWebhooks.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/webhooks/create",
      method: "POST",
      body: parameters,
      responseKey: "webhook",
      options
    });
  }
  delete(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/webhooks/delete",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/webhooks/get",
      method: "POST",
      body: parameters,
      responseKey: "webhook",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/webhooks/list",
      method: "GET",
      params: parameters,
      responseKey: "webhooks",
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/webhooks/update",
      method: "PUT",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/workspaces/customization-profiles/customization-profiles.ts
var SeamHttpWorkspacesCustomizationProfiles = class _SeamHttpWorkspacesCustomizationProfiles {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    if (!options.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpWorkspacesCustomizationProfiles(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpWorkspacesCustomizationProfiles(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpWorkspacesCustomizationProfiles(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpWorkspacesCustomizationProfiles.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpWorkspacesCustomizationProfiles.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpWorkspacesCustomizationProfiles(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpWorkspacesCustomizationProfiles(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/workspaces/customization_profiles/create",
      method: "POST",
      body: parameters,
      responseKey: "customization_profile",
      options
    });
  }
  get(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/workspaces/customization_profiles/get",
      method: "POST",
      body: parameters,
      responseKey: "customization_profile",
      options
    });
  }
  list(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/workspaces/customization_profiles/list",
      method: "POST",
      body: parameters,
      responseKey: "customization_profiles",
      options
    });
  }
  update(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/workspaces/customization_profiles/update",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
  uploadImages(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/workspaces/customization_profiles/upload_images",
      method: "POST",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/workspaces/workspaces.ts
var SeamHttpWorkspaces = class _SeamHttpWorkspaces {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpWorkspaces.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpWorkspaces.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get customizationProfiles() {
    return SeamHttpWorkspacesCustomizationProfiles.fromClient(
      this.client,
      this.defaults
    );
  }
  create(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/workspaces/create",
      method: "POST",
      body: parameters,
      responseKey: "workspace",
      options
    });
  }
  findAnything(parameters, options = {}) {
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return new SeamHttpRequest(this, {
      pathname: "/workspaces/find_anything",
      method: "POST",
      body: parameters,
      responseKey: "batch",
      options
    });
  }
  get(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/workspaces/get",
      method: "GET",
      params: parameters,
      responseKey: "workspace",
      options
    });
  }
  list(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/workspaces/list",
      method: "GET",
      params: parameters,
      responseKey: "workspaces",
      options
    });
  }
  resetSandbox(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/workspaces/reset_sandbox",
      method: "POST",
      body: parameters,
      responseKey: "action_attempt",
      options
    });
  }
  update(parameters, options = {}) {
    return new SeamHttpRequest(this, {
      pathname: "/workspaces/update",
      method: "PATCH",
      body: parameters,
      responseKey: void 0,
      options
    });
  }
};

// src/lib/seam/connect/routes/seam-http.ts
var SeamHttp = class _SeamHttp {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttp(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttp(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttp(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttp.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttp(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttp(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get accessCodes() {
    return SeamHttpAccessCodes.fromClient(this.client, this.defaults);
  }
  get accessGrants() {
    return SeamHttpAccessGrants.fromClient(this.client, this.defaults);
  }
  get accessMethods() {
    return SeamHttpAccessMethods.fromClient(this.client, this.defaults);
  }
  get acs() {
    return SeamHttpAcs.fromClient(this.client, this.defaults);
  }
  get actionAttempts() {
    return SeamHttpActionAttempts.fromClient(this.client, this.defaults);
  }
  get bridges() {
    return SeamHttpBridges.fromClient(this.client, this.defaults);
  }
  get clientSessions() {
    return SeamHttpClientSessions.fromClient(this.client, this.defaults);
  }
  get connectWebviews() {
    return SeamHttpConnectWebviews.fromClient(this.client, this.defaults);
  }
  get connectedAccounts() {
    return SeamHttpConnectedAccounts.fromClient(this.client, this.defaults);
  }
  get customers() {
    return SeamHttpCustomers.fromClient(this.client, this.defaults);
  }
  get devices() {
    return SeamHttpDevices.fromClient(this.client, this.defaults);
  }
  get events() {
    return SeamHttpEvents.fromClient(this.client, this.defaults);
  }
  get instantKeys() {
    return SeamHttpInstantKeys.fromClient(this.client, this.defaults);
  }
  get locks() {
    return SeamHttpLocks.fromClient(this.client, this.defaults);
  }
  get noiseSensors() {
    return SeamHttpNoiseSensors.fromClient(this.client, this.defaults);
  }
  get phones() {
    return SeamHttpPhones.fromClient(this.client, this.defaults);
  }
  get spaces() {
    return SeamHttpSpaces.fromClient(this.client, this.defaults);
  }
  get thermostats() {
    return SeamHttpThermostats.fromClient(this.client, this.defaults);
  }
  get unstablePartner() {
    return SeamHttpUnstablePartner.fromClient(this.client, this.defaults);
  }
  get userIdentities() {
    return SeamHttpUserIdentities.fromClient(this.client, this.defaults);
  }
  get webhooks() {
    return SeamHttpWebhooks.fromClient(this.client, this.defaults);
  }
  get workspaces() {
    return SeamHttpWorkspaces.fromClient(this.client, this.defaults);
  }
};

// src/lib/seam/connect/routes/seam-http-endpoints.ts
var SeamHttpEndpoints = class _SeamHttpEndpoints {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpEndpoints(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpEndpoints(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpEndpoints(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttpEndpoints.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpEndpoints.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpEndpoints(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpEndpoints(constructorOptions);
  }
  createPaginator(request) {
    return new SeamPaginator(this, request);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get "/access_codes/create"() {
    const { client, defaults } = this;
    return function accessCodesCreate(...args) {
      const seam = SeamHttpAccessCodes.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/access_codes/create_multiple"() {
    const { client, defaults } = this;
    return function accessCodesCreateMultiple(...args) {
      const seam = SeamHttpAccessCodes.fromClient(client, defaults);
      return seam.createMultiple(...args);
    };
  }
  get "/access_codes/delete"() {
    const { client, defaults } = this;
    return function accessCodesDelete(...args) {
      const seam = SeamHttpAccessCodes.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/access_codes/generate_code"() {
    const { client, defaults } = this;
    return function accessCodesGenerateCode(...args) {
      const seam = SeamHttpAccessCodes.fromClient(client, defaults);
      return seam.generateCode(...args);
    };
  }
  get "/access_codes/get"() {
    const { client, defaults } = this;
    return function accessCodesGet(...args) {
      const seam = SeamHttpAccessCodes.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/access_codes/list"() {
    const { client, defaults } = this;
    return function accessCodesList(...args) {
      const seam = SeamHttpAccessCodes.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/access_codes/pull_backup_access_code"() {
    const { client, defaults } = this;
    return function accessCodesPullBackupAccessCode(...args) {
      const seam = SeamHttpAccessCodes.fromClient(client, defaults);
      return seam.pullBackupAccessCode(...args);
    };
  }
  get "/access_codes/report_device_constraints"() {
    const { client, defaults } = this;
    return function accessCodesReportDeviceConstraints(...args) {
      const seam = SeamHttpAccessCodes.fromClient(client, defaults);
      return seam.reportDeviceConstraints(...args);
    };
  }
  get "/access_codes/update"() {
    const { client, defaults } = this;
    return function accessCodesUpdate(...args) {
      const seam = SeamHttpAccessCodes.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/access_codes/update_multiple"() {
    const { client, defaults } = this;
    return function accessCodesUpdateMultiple(...args) {
      const seam = SeamHttpAccessCodes.fromClient(client, defaults);
      return seam.updateMultiple(...args);
    };
  }
  get "/access_codes/simulate/create_unmanaged_access_code"() {
    const { client, defaults } = this;
    return function accessCodesSimulateCreateUnmanagedAccessCode(...args) {
      const seam = SeamHttpAccessCodesSimulate.fromClient(client, defaults);
      return seam.createUnmanagedAccessCode(...args);
    };
  }
  get "/access_codes/unmanaged/convert_to_managed"() {
    const { client, defaults } = this;
    return function accessCodesUnmanagedConvertToManaged(...args) {
      const seam = SeamHttpAccessCodesUnmanaged.fromClient(client, defaults);
      return seam.convertToManaged(...args);
    };
  }
  get "/access_codes/unmanaged/delete"() {
    const { client, defaults } = this;
    return function accessCodesUnmanagedDelete(...args) {
      const seam = SeamHttpAccessCodesUnmanaged.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/access_codes/unmanaged/get"() {
    const { client, defaults } = this;
    return function accessCodesUnmanagedGet(...args) {
      const seam = SeamHttpAccessCodesUnmanaged.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/access_codes/unmanaged/list"() {
    const { client, defaults } = this;
    return function accessCodesUnmanagedList(...args) {
      const seam = SeamHttpAccessCodesUnmanaged.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/access_codes/unmanaged/update"() {
    const { client, defaults } = this;
    return function accessCodesUnmanagedUpdate(...args) {
      const seam = SeamHttpAccessCodesUnmanaged.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/access_grants/create"() {
    const { client, defaults } = this;
    return function accessGrantsCreate(...args) {
      const seam = SeamHttpAccessGrants.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/access_grants/delete"() {
    const { client, defaults } = this;
    return function accessGrantsDelete(...args) {
      const seam = SeamHttpAccessGrants.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/access_grants/get"() {
    const { client, defaults } = this;
    return function accessGrantsGet(...args) {
      const seam = SeamHttpAccessGrants.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/access_grants/get_related"() {
    const { client, defaults } = this;
    return function accessGrantsGetRelated(...args) {
      const seam = SeamHttpAccessGrants.fromClient(client, defaults);
      return seam.getRelated(...args);
    };
  }
  get "/access_grants/list"() {
    const { client, defaults } = this;
    return function accessGrantsList(...args) {
      const seam = SeamHttpAccessGrants.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/access_grants/update"() {
    const { client, defaults } = this;
    return function accessGrantsUpdate(...args) {
      const seam = SeamHttpAccessGrants.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/access_grants/unmanaged/get"() {
    const { client, defaults } = this;
    return function accessGrantsUnmanagedGet(...args) {
      const seam = SeamHttpAccessGrantsUnmanaged.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/access_grants/unmanaged/list"() {
    const { client, defaults } = this;
    return function accessGrantsUnmanagedList(...args) {
      const seam = SeamHttpAccessGrantsUnmanaged.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/access_methods/delete"() {
    const { client, defaults } = this;
    return function accessMethodsDelete(...args) {
      const seam = SeamHttpAccessMethods.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/access_methods/encode"() {
    const { client, defaults } = this;
    return function accessMethodsEncode(...args) {
      const seam = SeamHttpAccessMethods.fromClient(client, defaults);
      return seam.encode(...args);
    };
  }
  get "/access_methods/get"() {
    const { client, defaults } = this;
    return function accessMethodsGet(...args) {
      const seam = SeamHttpAccessMethods.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/access_methods/get_related"() {
    const { client, defaults } = this;
    return function accessMethodsGetRelated(...args) {
      const seam = SeamHttpAccessMethods.fromClient(client, defaults);
      return seam.getRelated(...args);
    };
  }
  get "/access_methods/list"() {
    const { client, defaults } = this;
    return function accessMethodsList(...args) {
      const seam = SeamHttpAccessMethods.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/access_methods/unmanaged/get"() {
    const { client, defaults } = this;
    return function accessMethodsUnmanagedGet(...args) {
      const seam = SeamHttpAccessMethodsUnmanaged.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/access_methods/unmanaged/list"() {
    const { client, defaults } = this;
    return function accessMethodsUnmanagedList(...args) {
      const seam = SeamHttpAccessMethodsUnmanaged.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/acs/access_groups/add_user"() {
    const { client, defaults } = this;
    return function acsAccessGroupsAddUser(...args) {
      const seam = SeamHttpAcsAccessGroups.fromClient(client, defaults);
      return seam.addUser(...args);
    };
  }
  get "/acs/access_groups/get"() {
    const { client, defaults } = this;
    return function acsAccessGroupsGet(...args) {
      const seam = SeamHttpAcsAccessGroups.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/acs/access_groups/list"() {
    const { client, defaults } = this;
    return function acsAccessGroupsList(...args) {
      const seam = SeamHttpAcsAccessGroups.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/acs/access_groups/list_accessible_entrances"() {
    const { client, defaults } = this;
    return function acsAccessGroupsListAccessibleEntrances(...args) {
      const seam = SeamHttpAcsAccessGroups.fromClient(client, defaults);
      return seam.listAccessibleEntrances(...args);
    };
  }
  get "/acs/access_groups/list_users"() {
    const { client, defaults } = this;
    return function acsAccessGroupsListUsers(...args) {
      const seam = SeamHttpAcsAccessGroups.fromClient(client, defaults);
      return seam.listUsers(...args);
    };
  }
  get "/acs/access_groups/remove_user"() {
    const { client, defaults } = this;
    return function acsAccessGroupsRemoveUser(...args) {
      const seam = SeamHttpAcsAccessGroups.fromClient(client, defaults);
      return seam.removeUser(...args);
    };
  }
  get "/acs/access_groups/unmanaged/get"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function acsAccessGroupsUnmanagedGet(...args) {
      const seam = SeamHttpAcsAccessGroupsUnmanaged.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/acs/access_groups/unmanaged/list"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function acsAccessGroupsUnmanagedList(...args) {
      const seam = SeamHttpAcsAccessGroupsUnmanaged.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/acs/credential_pools/list"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function acsCredentialPoolsList(...args) {
      const seam = SeamHttpAcsCredentialPools.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/acs/credential_provisioning_automations/launch"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function acsCredentialProvisioningAutomationsLaunch(...args) {
      const seam = SeamHttpAcsCredentialProvisioningAutomations.fromClient(
        client,
        defaults
      );
      return seam.launch(...args);
    };
  }
  get "/acs/credentials/assign"() {
    const { client, defaults } = this;
    return function acsCredentialsAssign(...args) {
      const seam = SeamHttpAcsCredentials.fromClient(client, defaults);
      return seam.assign(...args);
    };
  }
  get "/acs/credentials/create"() {
    const { client, defaults } = this;
    return function acsCredentialsCreate(...args) {
      const seam = SeamHttpAcsCredentials.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/acs/credentials/create_offline_code"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function acsCredentialsCreateOfflineCode(...args) {
      const seam = SeamHttpAcsCredentials.fromClient(client, defaults);
      return seam.createOfflineCode(...args);
    };
  }
  get "/acs/credentials/delete"() {
    const { client, defaults } = this;
    return function acsCredentialsDelete(...args) {
      const seam = SeamHttpAcsCredentials.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/acs/credentials/get"() {
    const { client, defaults } = this;
    return function acsCredentialsGet(...args) {
      const seam = SeamHttpAcsCredentials.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/acs/credentials/list"() {
    const { client, defaults } = this;
    return function acsCredentialsList(...args) {
      const seam = SeamHttpAcsCredentials.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/acs/credentials/list_accessible_entrances"() {
    const { client, defaults } = this;
    return function acsCredentialsListAccessibleEntrances(...args) {
      const seam = SeamHttpAcsCredentials.fromClient(client, defaults);
      return seam.listAccessibleEntrances(...args);
    };
  }
  get "/acs/credentials/unassign"() {
    const { client, defaults } = this;
    return function acsCredentialsUnassign(...args) {
      const seam = SeamHttpAcsCredentials.fromClient(client, defaults);
      return seam.unassign(...args);
    };
  }
  get "/acs/credentials/update"() {
    const { client, defaults } = this;
    return function acsCredentialsUpdate(...args) {
      const seam = SeamHttpAcsCredentials.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/acs/credentials/unmanaged/get"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function acsCredentialsUnmanagedGet(...args) {
      const seam = SeamHttpAcsCredentialsUnmanaged.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/acs/credentials/unmanaged/list"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function acsCredentialsUnmanagedList(...args) {
      const seam = SeamHttpAcsCredentialsUnmanaged.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/acs/encoders/encode_credential"() {
    const { client, defaults } = this;
    return function acsEncodersEncodeCredential(...args) {
      const seam = SeamHttpAcsEncoders.fromClient(client, defaults);
      return seam.encodeCredential(...args);
    };
  }
  get "/acs/encoders/get"() {
    const { client, defaults } = this;
    return function acsEncodersGet(...args) {
      const seam = SeamHttpAcsEncoders.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/acs/encoders/list"() {
    const { client, defaults } = this;
    return function acsEncodersList(...args) {
      const seam = SeamHttpAcsEncoders.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/acs/encoders/scan_credential"() {
    const { client, defaults } = this;
    return function acsEncodersScanCredential(...args) {
      const seam = SeamHttpAcsEncoders.fromClient(client, defaults);
      return seam.scanCredential(...args);
    };
  }
  get "/acs/encoders/simulate/next_credential_encode_will_fail"() {
    const { client, defaults } = this;
    return function acsEncodersSimulateNextCredentialEncodeWillFail(...args) {
      const seam = SeamHttpAcsEncodersSimulate.fromClient(client, defaults);
      return seam.nextCredentialEncodeWillFail(...args);
    };
  }
  get "/acs/encoders/simulate/next_credential_encode_will_succeed"() {
    const { client, defaults } = this;
    return function acsEncodersSimulateNextCredentialEncodeWillSucceed(...args) {
      const seam = SeamHttpAcsEncodersSimulate.fromClient(client, defaults);
      return seam.nextCredentialEncodeWillSucceed(...args);
    };
  }
  get "/acs/encoders/simulate/next_credential_scan_will_fail"() {
    const { client, defaults } = this;
    return function acsEncodersSimulateNextCredentialScanWillFail(...args) {
      const seam = SeamHttpAcsEncodersSimulate.fromClient(client, defaults);
      return seam.nextCredentialScanWillFail(...args);
    };
  }
  get "/acs/encoders/simulate/next_credential_scan_will_succeed"() {
    const { client, defaults } = this;
    return function acsEncodersSimulateNextCredentialScanWillSucceed(...args) {
      const seam = SeamHttpAcsEncodersSimulate.fromClient(client, defaults);
      return seam.nextCredentialScanWillSucceed(...args);
    };
  }
  get "/acs/entrances/get"() {
    const { client, defaults } = this;
    return function acsEntrancesGet(...args) {
      const seam = SeamHttpAcsEntrances.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/acs/entrances/grant_access"() {
    const { client, defaults } = this;
    return function acsEntrancesGrantAccess(...args) {
      const seam = SeamHttpAcsEntrances.fromClient(client, defaults);
      return seam.grantAccess(...args);
    };
  }
  get "/acs/entrances/list"() {
    const { client, defaults } = this;
    return function acsEntrancesList(...args) {
      const seam = SeamHttpAcsEntrances.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/acs/entrances/list_credentials_with_access"() {
    const { client, defaults } = this;
    return function acsEntrancesListCredentialsWithAccess(...args) {
      const seam = SeamHttpAcsEntrances.fromClient(client, defaults);
      return seam.listCredentialsWithAccess(...args);
    };
  }
  get "/acs/systems/get"() {
    const { client, defaults } = this;
    return function acsSystemsGet(...args) {
      const seam = SeamHttpAcsSystems.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/acs/systems/list"() {
    const { client, defaults } = this;
    return function acsSystemsList(...args) {
      const seam = SeamHttpAcsSystems.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/acs/systems/list_compatible_credential_manager_acs_systems"() {
    const { client, defaults } = this;
    return function acsSystemsListCompatibleCredentialManagerAcsSystems(...args) {
      const seam = SeamHttpAcsSystems.fromClient(client, defaults);
      return seam.listCompatibleCredentialManagerAcsSystems(...args);
    };
  }
  get "/acs/users/add_to_access_group"() {
    const { client, defaults } = this;
    return function acsUsersAddToAccessGroup(...args) {
      const seam = SeamHttpAcsUsers.fromClient(client, defaults);
      return seam.addToAccessGroup(...args);
    };
  }
  get "/acs/users/create"() {
    const { client, defaults } = this;
    return function acsUsersCreate(...args) {
      const seam = SeamHttpAcsUsers.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/acs/users/delete"() {
    const { client, defaults } = this;
    return function acsUsersDelete(...args) {
      const seam = SeamHttpAcsUsers.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/acs/users/get"() {
    const { client, defaults } = this;
    return function acsUsersGet(...args) {
      const seam = SeamHttpAcsUsers.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/acs/users/list"() {
    const { client, defaults } = this;
    return function acsUsersList(...args) {
      const seam = SeamHttpAcsUsers.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/acs/users/list_accessible_entrances"() {
    const { client, defaults } = this;
    return function acsUsersListAccessibleEntrances(...args) {
      const seam = SeamHttpAcsUsers.fromClient(client, defaults);
      return seam.listAccessibleEntrances(...args);
    };
  }
  get "/acs/users/remove_from_access_group"() {
    const { client, defaults } = this;
    return function acsUsersRemoveFromAccessGroup(...args) {
      const seam = SeamHttpAcsUsers.fromClient(client, defaults);
      return seam.removeFromAccessGroup(...args);
    };
  }
  get "/acs/users/revoke_access_to_all_entrances"() {
    const { client, defaults } = this;
    return function acsUsersRevokeAccessToAllEntrances(...args) {
      const seam = SeamHttpAcsUsers.fromClient(client, defaults);
      return seam.revokeAccessToAllEntrances(...args);
    };
  }
  get "/acs/users/suspend"() {
    const { client, defaults } = this;
    return function acsUsersSuspend(...args) {
      const seam = SeamHttpAcsUsers.fromClient(client, defaults);
      return seam.suspend(...args);
    };
  }
  get "/acs/users/unsuspend"() {
    const { client, defaults } = this;
    return function acsUsersUnsuspend(...args) {
      const seam = SeamHttpAcsUsers.fromClient(client, defaults);
      return seam.unsuspend(...args);
    };
  }
  get "/acs/users/update"() {
    const { client, defaults } = this;
    return function acsUsersUpdate(...args) {
      const seam = SeamHttpAcsUsers.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/acs/users/unmanaged/get"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function acsUsersUnmanagedGet(...args) {
      const seam = SeamHttpAcsUsersUnmanaged.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/acs/users/unmanaged/list"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function acsUsersUnmanagedList(...args) {
      const seam = SeamHttpAcsUsersUnmanaged.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/action_attempts/get"() {
    const { client, defaults } = this;
    return function actionAttemptsGet(...args) {
      const seam = SeamHttpActionAttempts.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/action_attempts/list"() {
    const { client, defaults } = this;
    return function actionAttemptsList(...args) {
      const seam = SeamHttpActionAttempts.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/bridges/get"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function bridgesGet(...args) {
      const seam = SeamHttpBridges.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/bridges/list"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function bridgesList(...args) {
      const seam = SeamHttpBridges.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/client_sessions/create"() {
    const { client, defaults } = this;
    return function clientSessionsCreate(...args) {
      const seam = SeamHttpClientSessions.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/client_sessions/delete"() {
    const { client, defaults } = this;
    return function clientSessionsDelete(...args) {
      const seam = SeamHttpClientSessions.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/client_sessions/get"() {
    const { client, defaults } = this;
    return function clientSessionsGet(...args) {
      const seam = SeamHttpClientSessions.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/client_sessions/get_or_create"() {
    const { client, defaults } = this;
    return function clientSessionsGetOrCreate(...args) {
      const seam = SeamHttpClientSessions.fromClient(client, defaults);
      return seam.getOrCreate(...args);
    };
  }
  get "/client_sessions/grant_access"() {
    const { client, defaults } = this;
    return function clientSessionsGrantAccess(...args) {
      const seam = SeamHttpClientSessions.fromClient(client, defaults);
      return seam.grantAccess(...args);
    };
  }
  get "/client_sessions/list"() {
    const { client, defaults } = this;
    return function clientSessionsList(...args) {
      const seam = SeamHttpClientSessions.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/client_sessions/revoke"() {
    const { client, defaults } = this;
    return function clientSessionsRevoke(...args) {
      const seam = SeamHttpClientSessions.fromClient(client, defaults);
      return seam.revoke(...args);
    };
  }
  get "/connect_webviews/create"() {
    const { client, defaults } = this;
    return function connectWebviewsCreate(...args) {
      const seam = SeamHttpConnectWebviews.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/connect_webviews/delete"() {
    const { client, defaults } = this;
    return function connectWebviewsDelete(...args) {
      const seam = SeamHttpConnectWebviews.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/connect_webviews/get"() {
    const { client, defaults } = this;
    return function connectWebviewsGet(...args) {
      const seam = SeamHttpConnectWebviews.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/connect_webviews/list"() {
    const { client, defaults } = this;
    return function connectWebviewsList(...args) {
      const seam = SeamHttpConnectWebviews.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/connected_accounts/delete"() {
    const { client, defaults } = this;
    return function connectedAccountsDelete(...args) {
      const seam = SeamHttpConnectedAccounts.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/connected_accounts/get"() {
    const { client, defaults } = this;
    return function connectedAccountsGet(...args) {
      const seam = SeamHttpConnectedAccounts.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/connected_accounts/list"() {
    const { client, defaults } = this;
    return function connectedAccountsList(...args) {
      const seam = SeamHttpConnectedAccounts.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/connected_accounts/sync"() {
    const { client, defaults } = this;
    return function connectedAccountsSync(...args) {
      const seam = SeamHttpConnectedAccounts.fromClient(client, defaults);
      return seam.sync(...args);
    };
  }
  get "/connected_accounts/update"() {
    const { client, defaults } = this;
    return function connectedAccountsUpdate(...args) {
      const seam = SeamHttpConnectedAccounts.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/customers/create_portal"() {
    const { client, defaults } = this;
    return function customersCreatePortal(...args) {
      const seam = SeamHttpCustomers.fromClient(client, defaults);
      return seam.createPortal(...args);
    };
  }
  get "/customers/delete_data"() {
    const { client, defaults } = this;
    return function customersDeleteData(...args) {
      const seam = SeamHttpCustomers.fromClient(client, defaults);
      return seam.deleteData(...args);
    };
  }
  get "/customers/push_data"() {
    const { client, defaults } = this;
    return function customersPushData(...args) {
      const seam = SeamHttpCustomers.fromClient(client, defaults);
      return seam.pushData(...args);
    };
  }
  get "/devices/delete"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function devicesDelete(...args) {
      const seam = SeamHttpDevices.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/devices/get"() {
    const { client, defaults } = this;
    return function devicesGet(...args) {
      const seam = SeamHttpDevices.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/devices/list"() {
    const { client, defaults } = this;
    return function devicesList(...args) {
      const seam = SeamHttpDevices.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/devices/list_device_providers"() {
    const { client, defaults } = this;
    return function devicesListDeviceProviders(...args) {
      const seam = SeamHttpDevices.fromClient(client, defaults);
      return seam.listDeviceProviders(...args);
    };
  }
  get "/devices/update"() {
    const { client, defaults } = this;
    return function devicesUpdate(...args) {
      const seam = SeamHttpDevices.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/devices/simulate/connect"() {
    const { client, defaults } = this;
    return function devicesSimulateConnect(...args) {
      const seam = SeamHttpDevicesSimulate.fromClient(client, defaults);
      return seam.connect(...args);
    };
  }
  get "/devices/simulate/connect_to_hub"() {
    const { client, defaults } = this;
    return function devicesSimulateConnectToHub(...args) {
      const seam = SeamHttpDevicesSimulate.fromClient(client, defaults);
      return seam.connectToHub(...args);
    };
  }
  get "/devices/simulate/disconnect"() {
    const { client, defaults } = this;
    return function devicesSimulateDisconnect(...args) {
      const seam = SeamHttpDevicesSimulate.fromClient(client, defaults);
      return seam.disconnect(...args);
    };
  }
  get "/devices/simulate/disconnect_from_hub"() {
    const { client, defaults } = this;
    return function devicesSimulateDisconnectFromHub(...args) {
      const seam = SeamHttpDevicesSimulate.fromClient(client, defaults);
      return seam.disconnectFromHub(...args);
    };
  }
  get "/devices/simulate/paid_subscription"() {
    const { client, defaults } = this;
    return function devicesSimulatePaidSubscription(...args) {
      const seam = SeamHttpDevicesSimulate.fromClient(client, defaults);
      return seam.paidSubscription(...args);
    };
  }
  get "/devices/simulate/remove"() {
    const { client, defaults } = this;
    return function devicesSimulateRemove(...args) {
      const seam = SeamHttpDevicesSimulate.fromClient(client, defaults);
      return seam.remove(...args);
    };
  }
  get "/devices/unmanaged/get"() {
    const { client, defaults } = this;
    return function devicesUnmanagedGet(...args) {
      const seam = SeamHttpDevicesUnmanaged.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/devices/unmanaged/list"() {
    const { client, defaults } = this;
    return function devicesUnmanagedList(...args) {
      const seam = SeamHttpDevicesUnmanaged.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/devices/unmanaged/update"() {
    const { client, defaults } = this;
    return function devicesUnmanagedUpdate(...args) {
      const seam = SeamHttpDevicesUnmanaged.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/events/get"() {
    const { client, defaults } = this;
    return function eventsGet(...args) {
      const seam = SeamHttpEvents.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/events/list"() {
    const { client, defaults } = this;
    return function eventsList(...args) {
      const seam = SeamHttpEvents.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/instant_keys/delete"() {
    const { client, defaults } = this;
    return function instantKeysDelete(...args) {
      const seam = SeamHttpInstantKeys.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/instant_keys/get"() {
    const { client, defaults } = this;
    return function instantKeysGet(...args) {
      const seam = SeamHttpInstantKeys.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/instant_keys/list"() {
    const { client, defaults } = this;
    return function instantKeysList(...args) {
      const seam = SeamHttpInstantKeys.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/locks/get"() {
    const { client, defaults } = this;
    return function locksGet(...args) {
      const seam = SeamHttpLocks.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/locks/list"() {
    const { client, defaults } = this;
    return function locksList(...args) {
      const seam = SeamHttpLocks.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/locks/lock_door"() {
    const { client, defaults } = this;
    return function locksLockDoor(...args) {
      const seam = SeamHttpLocks.fromClient(client, defaults);
      return seam.lockDoor(...args);
    };
  }
  get "/locks/unlock_door"() {
    const { client, defaults } = this;
    return function locksUnlockDoor(...args) {
      const seam = SeamHttpLocks.fromClient(client, defaults);
      return seam.unlockDoor(...args);
    };
  }
  get "/locks/simulate/keypad_code_entry"() {
    const { client, defaults } = this;
    return function locksSimulateKeypadCodeEntry(...args) {
      const seam = SeamHttpLocksSimulate.fromClient(client, defaults);
      return seam.keypadCodeEntry(...args);
    };
  }
  get "/locks/simulate/manual_lock_via_keypad"() {
    const { client, defaults } = this;
    return function locksSimulateManualLockViaKeypad(...args) {
      const seam = SeamHttpLocksSimulate.fromClient(client, defaults);
      return seam.manualLockViaKeypad(...args);
    };
  }
  get "/noise_sensors/list"() {
    const { client, defaults } = this;
    return function noiseSensorsList(...args) {
      const seam = SeamHttpNoiseSensors.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/noise_sensors/noise_thresholds/create"() {
    const { client, defaults } = this;
    return function noiseSensorsNoiseThresholdsCreate(...args) {
      const seam = SeamHttpNoiseSensorsNoiseThresholds.fromClient(
        client,
        defaults
      );
      return seam.create(...args);
    };
  }
  get "/noise_sensors/noise_thresholds/delete"() {
    const { client, defaults } = this;
    return function noiseSensorsNoiseThresholdsDelete(...args) {
      const seam = SeamHttpNoiseSensorsNoiseThresholds.fromClient(
        client,
        defaults
      );
      return seam.delete(...args);
    };
  }
  get "/noise_sensors/noise_thresholds/get"() {
    const { client, defaults } = this;
    return function noiseSensorsNoiseThresholdsGet(...args) {
      const seam = SeamHttpNoiseSensorsNoiseThresholds.fromClient(
        client,
        defaults
      );
      return seam.get(...args);
    };
  }
  get "/noise_sensors/noise_thresholds/list"() {
    const { client, defaults } = this;
    return function noiseSensorsNoiseThresholdsList(...args) {
      const seam = SeamHttpNoiseSensorsNoiseThresholds.fromClient(
        client,
        defaults
      );
      return seam.list(...args);
    };
  }
  get "/noise_sensors/noise_thresholds/update"() {
    const { client, defaults } = this;
    return function noiseSensorsNoiseThresholdsUpdate(...args) {
      const seam = SeamHttpNoiseSensorsNoiseThresholds.fromClient(
        client,
        defaults
      );
      return seam.update(...args);
    };
  }
  get "/noise_sensors/simulate/trigger_noise_threshold"() {
    const { client, defaults } = this;
    return function noiseSensorsSimulateTriggerNoiseThreshold(...args) {
      const seam = SeamHttpNoiseSensorsSimulate.fromClient(client, defaults);
      return seam.triggerNoiseThreshold(...args);
    };
  }
  get "/phones/deactivate"() {
    const { client, defaults } = this;
    return function phonesDeactivate(...args) {
      const seam = SeamHttpPhones.fromClient(client, defaults);
      return seam.deactivate(...args);
    };
  }
  get "/phones/get"() {
    const { client, defaults } = this;
    return function phonesGet(...args) {
      const seam = SeamHttpPhones.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/phones/list"() {
    const { client, defaults } = this;
    return function phonesList(...args) {
      const seam = SeamHttpPhones.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/phones/simulate/create_sandbox_phone"() {
    const { client, defaults } = this;
    return function phonesSimulateCreateSandboxPhone(...args) {
      const seam = SeamHttpPhonesSimulate.fromClient(client, defaults);
      return seam.createSandboxPhone(...args);
    };
  }
  get "/seam/console/v1/get_resource_locator"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function seamConsoleV1GetResourceLocator(...args) {
      const seam = SeamHttpSeamConsoleV1.fromClient(client, defaults);
      return seam.getResourceLocator(...args);
    };
  }
  get "/seam/console/v1/timelines/get"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function seamConsoleV1TimelinesGet(...args) {
      const seam = SeamHttpSeamConsoleV1Timelines.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/seam/customer/v1/automation_runs/list"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function seamCustomerV1AutomationRunsList(...args) {
      const seam = SeamHttpSeamCustomerV1AutomationRuns.fromClient(
        client,
        defaults
      );
      return seam.list(...args);
    };
  }
  get "/seam/customer/v1/automations/delete"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function seamCustomerV1AutomationsDelete(...args) {
      const seam = SeamHttpSeamCustomerV1Automations.fromClient(
        client,
        defaults
      );
      return seam.delete(...args);
    };
  }
  get "/seam/customer/v1/automations/get"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function seamCustomerV1AutomationsGet(...args) {
      const seam = SeamHttpSeamCustomerV1Automations.fromClient(
        client,
        defaults
      );
      return seam.get(...args);
    };
  }
  get "/seam/customer/v1/automations/update"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function seamCustomerV1AutomationsUpdate(...args) {
      const seam = SeamHttpSeamCustomerV1Automations.fromClient(
        client,
        defaults
      );
      return seam.update(...args);
    };
  }
  get "/seam/customer/v1/events/list"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function seamCustomerV1EventsList(...args) {
      const seam = SeamHttpSeamCustomerV1Events.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/seam/customer/v1/portals/get"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function seamCustomerV1PortalsGet(...args) {
      const seam = SeamHttpSeamCustomerV1Portals.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/seam/customer/v1/reservations/get"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function seamCustomerV1ReservationsGet(...args) {
      const seam = SeamHttpSeamCustomerV1Reservations.fromClient(
        client,
        defaults
      );
      return seam.get(...args);
    };
  }
  get "/seam/customer/v1/reservations/list"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function seamCustomerV1ReservationsList(...args) {
      const seam = SeamHttpSeamCustomerV1Reservations.fromClient(
        client,
        defaults
      );
      return seam.list(...args);
    };
  }
  get "/seam/customer/v1/settings/get"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function seamCustomerV1SettingsGet(...args) {
      const seam = SeamHttpSeamCustomerV1Settings.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/seam/customer/v1/settings/update"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function seamCustomerV1SettingsUpdate(...args) {
      const seam = SeamHttpSeamCustomerV1Settings.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/seam/customer/v1/spaces/create"() {
    const { client, defaults } = this;
    return function seamCustomerV1SpacesCreate(...args) {
      const seam = SeamHttpSeamCustomerV1Spaces.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/seam/customer/v1/spaces/list"() {
    const { client, defaults } = this;
    return function seamCustomerV1SpacesList(...args) {
      const seam = SeamHttpSeamCustomerV1Spaces.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/seam/partner/v1/building_blocks/spaces/auto_map"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function seamPartnerV1BuildingBlocksSpacesAutoMap(...args) {
      const seam = SeamHttpSeamPartnerV1BuildingBlocksSpaces.fromClient(
        client,
        defaults
      );
      return seam.autoMap(...args);
    };
  }
  get "/spaces/add_acs_entrances"() {
    const { client, defaults } = this;
    return function spacesAddAcsEntrances(...args) {
      const seam = SeamHttpSpaces.fromClient(client, defaults);
      return seam.addAcsEntrances(...args);
    };
  }
  get "/spaces/add_devices"() {
    const { client, defaults } = this;
    return function spacesAddDevices(...args) {
      const seam = SeamHttpSpaces.fromClient(client, defaults);
      return seam.addDevices(...args);
    };
  }
  get "/spaces/create"() {
    const { client, defaults } = this;
    return function spacesCreate(...args) {
      const seam = SeamHttpSpaces.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/spaces/delete"() {
    const { client, defaults } = this;
    return function spacesDelete(...args) {
      const seam = SeamHttpSpaces.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/spaces/get"() {
    const { client, defaults } = this;
    return function spacesGet(...args) {
      const seam = SeamHttpSpaces.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/spaces/get_related"() {
    const { client, defaults } = this;
    return function spacesGetRelated(...args) {
      const seam = SeamHttpSpaces.fromClient(client, defaults);
      return seam.getRelated(...args);
    };
  }
  get "/spaces/list"() {
    const { client, defaults } = this;
    return function spacesList(...args) {
      const seam = SeamHttpSpaces.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/spaces/remove_acs_entrances"() {
    const { client, defaults } = this;
    return function spacesRemoveAcsEntrances(...args) {
      const seam = SeamHttpSpaces.fromClient(client, defaults);
      return seam.removeAcsEntrances(...args);
    };
  }
  get "/spaces/remove_devices"() {
    const { client, defaults } = this;
    return function spacesRemoveDevices(...args) {
      const seam = SeamHttpSpaces.fromClient(client, defaults);
      return seam.removeDevices(...args);
    };
  }
  get "/spaces/update"() {
    const { client, defaults } = this;
    return function spacesUpdate(...args) {
      const seam = SeamHttpSpaces.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/thermostats/activate_climate_preset"() {
    const { client, defaults } = this;
    return function thermostatsActivateClimatePreset(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.activateClimatePreset(...args);
    };
  }
  get "/thermostats/cool"() {
    const { client, defaults } = this;
    return function thermostatsCool(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.cool(...args);
    };
  }
  get "/thermostats/create_climate_preset"() {
    const { client, defaults } = this;
    return function thermostatsCreateClimatePreset(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.createClimatePreset(...args);
    };
  }
  get "/thermostats/delete_climate_preset"() {
    const { client, defaults } = this;
    return function thermostatsDeleteClimatePreset(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.deleteClimatePreset(...args);
    };
  }
  get "/thermostats/get"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function thermostatsGet(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/thermostats/heat"() {
    const { client, defaults } = this;
    return function thermostatsHeat(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.heat(...args);
    };
  }
  get "/thermostats/heat_cool"() {
    const { client, defaults } = this;
    return function thermostatsHeatCool(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.heatCool(...args);
    };
  }
  get "/thermostats/list"() {
    const { client, defaults } = this;
    return function thermostatsList(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/thermostats/off"() {
    const { client, defaults } = this;
    return function thermostatsOff(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.off(...args);
    };
  }
  get "/thermostats/set_fallback_climate_preset"() {
    const { client, defaults } = this;
    return function thermostatsSetFallbackClimatePreset(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.setFallbackClimatePreset(...args);
    };
  }
  get "/thermostats/set_fan_mode"() {
    const { client, defaults } = this;
    return function thermostatsSetFanMode(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.setFanMode(...args);
    };
  }
  get "/thermostats/set_hvac_mode"() {
    const { client, defaults } = this;
    return function thermostatsSetHvacMode(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.setHvacMode(...args);
    };
  }
  get "/thermostats/set_temperature_threshold"() {
    const { client, defaults } = this;
    return function thermostatsSetTemperatureThreshold(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.setTemperatureThreshold(...args);
    };
  }
  get "/thermostats/update_climate_preset"() {
    const { client, defaults } = this;
    return function thermostatsUpdateClimatePreset(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.updateClimatePreset(...args);
    };
  }
  get "/thermostats/update_weekly_program"() {
    const { client, defaults } = this;
    return function thermostatsUpdateWeeklyProgram(...args) {
      const seam = SeamHttpThermostats.fromClient(client, defaults);
      return seam.updateWeeklyProgram(...args);
    };
  }
  get "/thermostats/daily_programs/create"() {
    const { client, defaults } = this;
    return function thermostatsDailyProgramsCreate(...args) {
      const seam = SeamHttpThermostatsDailyPrograms.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/thermostats/daily_programs/delete"() {
    const { client, defaults } = this;
    return function thermostatsDailyProgramsDelete(...args) {
      const seam = SeamHttpThermostatsDailyPrograms.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/thermostats/daily_programs/update"() {
    const { client, defaults } = this;
    return function thermostatsDailyProgramsUpdate(...args) {
      const seam = SeamHttpThermostatsDailyPrograms.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/thermostats/schedules/create"() {
    const { client, defaults } = this;
    return function thermostatsSchedulesCreate(...args) {
      const seam = SeamHttpThermostatsSchedules.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/thermostats/schedules/delete"() {
    const { client, defaults } = this;
    return function thermostatsSchedulesDelete(...args) {
      const seam = SeamHttpThermostatsSchedules.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/thermostats/schedules/get"() {
    const { client, defaults } = this;
    return function thermostatsSchedulesGet(...args) {
      const seam = SeamHttpThermostatsSchedules.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/thermostats/schedules/list"() {
    const { client, defaults } = this;
    return function thermostatsSchedulesList(...args) {
      const seam = SeamHttpThermostatsSchedules.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/thermostats/schedules/update"() {
    const { client, defaults } = this;
    return function thermostatsSchedulesUpdate(...args) {
      const seam = SeamHttpThermostatsSchedules.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/thermostats/simulate/hvac_mode_adjusted"() {
    const { client, defaults } = this;
    return function thermostatsSimulateHvacModeAdjusted(...args) {
      const seam = SeamHttpThermostatsSimulate.fromClient(client, defaults);
      return seam.hvacModeAdjusted(...args);
    };
  }
  get "/thermostats/simulate/temperature_reached"() {
    const { client, defaults } = this;
    return function thermostatsSimulateTemperatureReached(...args) {
      const seam = SeamHttpThermostatsSimulate.fromClient(client, defaults);
      return seam.temperatureReached(...args);
    };
  }
  get "/unstable_partner/building_blocks/connect_accounts"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function unstablePartnerBuildingBlocksConnectAccounts(...args) {
      const seam = SeamHttpUnstablePartnerBuildingBlocks.fromClient(
        client,
        defaults
      );
      return seam.connectAccounts(...args);
    };
  }
  get "/unstable_partner/building_blocks/generate_magic_link"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function unstablePartnerBuildingBlocksGenerateMagicLink(...args) {
      const seam = SeamHttpUnstablePartnerBuildingBlocks.fromClient(
        client,
        defaults
      );
      return seam.generateMagicLink(...args);
    };
  }
  get "/unstable_partner/building_blocks/manage_devices"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function unstablePartnerBuildingBlocksManageDevices(...args) {
      const seam = SeamHttpUnstablePartnerBuildingBlocks.fromClient(
        client,
        defaults
      );
      return seam.manageDevices(...args);
    };
  }
  get "/unstable_partner/building_blocks/organize_spaces"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function unstablePartnerBuildingBlocksOrganizeSpaces(...args) {
      const seam = SeamHttpUnstablePartnerBuildingBlocks.fromClient(
        client,
        defaults
      );
      return seam.organizeSpaces(...args);
    };
  }
  get "/user_identities/add_acs_user"() {
    const { client, defaults } = this;
    return function userIdentitiesAddAcsUser(...args) {
      const seam = SeamHttpUserIdentities.fromClient(client, defaults);
      return seam.addAcsUser(...args);
    };
  }
  get "/user_identities/create"() {
    const { client, defaults } = this;
    return function userIdentitiesCreate(...args) {
      const seam = SeamHttpUserIdentities.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/user_identities/delete"() {
    const { client, defaults } = this;
    return function userIdentitiesDelete(...args) {
      const seam = SeamHttpUserIdentities.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/user_identities/generate_instant_key"() {
    const { client, defaults } = this;
    return function userIdentitiesGenerateInstantKey(...args) {
      const seam = SeamHttpUserIdentities.fromClient(client, defaults);
      return seam.generateInstantKey(...args);
    };
  }
  get "/user_identities/get"() {
    const { client, defaults } = this;
    return function userIdentitiesGet(...args) {
      const seam = SeamHttpUserIdentities.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/user_identities/grant_access_to_device"() {
    const { client, defaults } = this;
    return function userIdentitiesGrantAccessToDevice(...args) {
      const seam = SeamHttpUserIdentities.fromClient(client, defaults);
      return seam.grantAccessToDevice(...args);
    };
  }
  get "/user_identities/list"() {
    const { client, defaults } = this;
    return function userIdentitiesList(...args) {
      const seam = SeamHttpUserIdentities.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/user_identities/list_accessible_devices"() {
    const { client, defaults } = this;
    return function userIdentitiesListAccessibleDevices(...args) {
      const seam = SeamHttpUserIdentities.fromClient(client, defaults);
      return seam.listAccessibleDevices(...args);
    };
  }
  get "/user_identities/list_acs_systems"() {
    const { client, defaults } = this;
    return function userIdentitiesListAcsSystems(...args) {
      const seam = SeamHttpUserIdentities.fromClient(client, defaults);
      return seam.listAcsSystems(...args);
    };
  }
  get "/user_identities/list_acs_users"() {
    const { client, defaults } = this;
    return function userIdentitiesListAcsUsers(...args) {
      const seam = SeamHttpUserIdentities.fromClient(client, defaults);
      return seam.listAcsUsers(...args);
    };
  }
  get "/user_identities/remove_acs_user"() {
    const { client, defaults } = this;
    return function userIdentitiesRemoveAcsUser(...args) {
      const seam = SeamHttpUserIdentities.fromClient(client, defaults);
      return seam.removeAcsUser(...args);
    };
  }
  get "/user_identities/revoke_access_to_device"() {
    const { client, defaults } = this;
    return function userIdentitiesRevokeAccessToDevice(...args) {
      const seam = SeamHttpUserIdentities.fromClient(client, defaults);
      return seam.revokeAccessToDevice(...args);
    };
  }
  get "/user_identities/update"() {
    const { client, defaults } = this;
    return function userIdentitiesUpdate(...args) {
      const seam = SeamHttpUserIdentities.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/user_identities/enrollment_automations/delete"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function userIdentitiesEnrollmentAutomationsDelete(...args) {
      const seam = SeamHttpUserIdentitiesEnrollmentAutomations.fromClient(
        client,
        defaults
      );
      return seam.delete(...args);
    };
  }
  get "/user_identities/enrollment_automations/get"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function userIdentitiesEnrollmentAutomationsGet(...args) {
      const seam = SeamHttpUserIdentitiesEnrollmentAutomations.fromClient(
        client,
        defaults
      );
      return seam.get(...args);
    };
  }
  get "/user_identities/enrollment_automations/launch"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function userIdentitiesEnrollmentAutomationsLaunch(...args) {
      const seam = SeamHttpUserIdentitiesEnrollmentAutomations.fromClient(
        client,
        defaults
      );
      return seam.launch(...args);
    };
  }
  get "/user_identities/enrollment_automations/list"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function userIdentitiesEnrollmentAutomationsList(...args) {
      const seam = SeamHttpUserIdentitiesEnrollmentAutomations.fromClient(
        client,
        defaults
      );
      return seam.list(...args);
    };
  }
  get "/user_identities/unmanaged/get"() {
    const { client, defaults } = this;
    return function userIdentitiesUnmanagedGet(...args) {
      const seam = SeamHttpUserIdentitiesUnmanaged.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/user_identities/unmanaged/list"() {
    const { client, defaults } = this;
    return function userIdentitiesUnmanagedList(...args) {
      const seam = SeamHttpUserIdentitiesUnmanaged.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/webhooks/create"() {
    const { client, defaults } = this;
    return function webhooksCreate(...args) {
      const seam = SeamHttpWebhooks.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/webhooks/delete"() {
    const { client, defaults } = this;
    return function webhooksDelete(...args) {
      const seam = SeamHttpWebhooks.fromClient(client, defaults);
      return seam.delete(...args);
    };
  }
  get "/webhooks/get"() {
    const { client, defaults } = this;
    return function webhooksGet(...args) {
      const seam = SeamHttpWebhooks.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/webhooks/list"() {
    const { client, defaults } = this;
    return function webhooksList(...args) {
      const seam = SeamHttpWebhooks.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/webhooks/update"() {
    const { client, defaults } = this;
    return function webhooksUpdate(...args) {
      const seam = SeamHttpWebhooks.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/workspaces/create"() {
    const { client, defaults } = this;
    return function workspacesCreate(...args) {
      const seam = SeamHttpWorkspaces.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/workspaces/find_anything"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function workspacesFindAnything(...args) {
      const seam = SeamHttpWorkspaces.fromClient(client, defaults);
      return seam.findAnything(...args);
    };
  }
  get "/workspaces/get"() {
    const { client, defaults } = this;
    return function workspacesGet(...args) {
      const seam = SeamHttpWorkspaces.fromClient(client, defaults);
      return seam.get(...args);
    };
  }
  get "/workspaces/list"() {
    const { client, defaults } = this;
    return function workspacesList(...args) {
      const seam = SeamHttpWorkspaces.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
  get "/workspaces/reset_sandbox"() {
    const { client, defaults } = this;
    return function workspacesResetSandbox(...args) {
      const seam = SeamHttpWorkspaces.fromClient(client, defaults);
      return seam.resetSandbox(...args);
    };
  }
  get "/workspaces/update"() {
    const { client, defaults } = this;
    return function workspacesUpdate(...args) {
      const seam = SeamHttpWorkspaces.fromClient(client, defaults);
      return seam.update(...args);
    };
  }
  get "/workspaces/customization_profiles/create"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function workspacesCustomizationProfilesCreate(...args) {
      const seam = SeamHttpWorkspacesCustomizationProfiles.fromClient(
        client,
        defaults
      );
      return seam.create(...args);
    };
  }
  get "/workspaces/customization_profiles/get"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function workspacesCustomizationProfilesGet(...args) {
      const seam = SeamHttpWorkspacesCustomizationProfiles.fromClient(
        client,
        defaults
      );
      return seam.get(...args);
    };
  }
  get "/workspaces/customization_profiles/list"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function workspacesCustomizationProfilesList(...args) {
      const seam = SeamHttpWorkspacesCustomizationProfiles.fromClient(
        client,
        defaults
      );
      return seam.list(...args);
    };
  }
  get "/workspaces/customization_profiles/update"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function workspacesCustomizationProfilesUpdate(...args) {
      const seam = SeamHttpWorkspacesCustomizationProfiles.fromClient(
        client,
        defaults
      );
      return seam.update(...args);
    };
  }
  get "/workspaces/customization_profiles/upload_images"() {
    const { client, defaults } = this;
    if (!this.defaults.isUndocumentedApiEnabled) {
      throw new Error(
        "Cannot use undocumented API without isUndocumentedApiEnabled"
      );
    }
    return function workspacesCustomizationProfilesUploadImages(...args) {
      const seam = SeamHttpWorkspacesCustomizationProfiles.fromClient(
        client,
        defaults
      );
      return seam.uploadImages(...args);
    };
  }
};

// src/lib/seam/connect/routes/seam-http-endpoints-without-workspace.ts
var SeamHttpEndpointsWithoutWorkspace = class _SeamHttpEndpointsWithoutWorkspace {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(options = {}) {
    const opts = parseOptions(options);
    this.client = "client" in opts ? opts.client : createClient(opts);
    this.defaults = limitToSeamHttpRequestOptions(opts);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpWithoutWorkspaceOptionsWithClient(constructorOptions)) {
      throw new SeamHttpWithoutWorkspaceInvalidOptionsError("Missing client");
    }
    return new _SeamHttpEndpointsWithoutWorkspace(constructorOptions);
  }
  static fromConsoleSessionToken(consoleSessionToken, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken };
    if (!isSeamHttpWithoutWorkspaceOptionsWithConsoleSessionToken(
      constructorOptions
    )) {
      throw new SeamHttpWithoutWorkspaceInvalidOptionsError(
        "Missing consoleSessionToken"
      );
    }
    return new _SeamHttpEndpointsWithoutWorkspace(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, options = {}) {
    const constructorOptions = { ...options, personalAccessToken };
    if (!isSeamHttpWithoutWorkspaceOptionsWithPersonalAccessToken(
      constructorOptions
    )) {
      throw new SeamHttpWithoutWorkspaceInvalidOptionsError(
        "Missing personalAccessToken"
      );
    }
    return new _SeamHttpEndpointsWithoutWorkspace(constructorOptions);
  }
  get "/workspaces/create"() {
    const { client, defaults } = this;
    return function workspacesCreate(...args) {
      const seam = SeamHttpWorkspaces.fromClient(client, defaults);
      return seam.create(...args);
    };
  }
  get "/workspaces/list"() {
    const { client, defaults } = this;
    return function workspacesList(...args) {
      const seam = SeamHttpWorkspaces.fromClient(client, defaults);
      return seam.list(...args);
    };
  }
};

// src/lib/seam/connect/routes/seam-http-without-workspace.ts
var SeamHttpWithoutWorkspace = class _SeamHttpWithoutWorkspace {
  client;
  defaults;
  ltsVersion = seamApiLtsVersion;
  static ltsVersion = seamApiLtsVersion;
  constructor(options = {}) {
    const opts = parseOptions(options);
    this.client = "client" in opts ? opts.client : createClient(opts);
    this.defaults = limitToSeamHttpRequestOptions(opts);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpWithoutWorkspaceOptionsWithClient(constructorOptions)) {
      throw new SeamHttpWithoutWorkspaceInvalidOptionsError("Missing client");
    }
    return new _SeamHttpWithoutWorkspace(constructorOptions);
  }
  static fromConsoleSessionToken(consoleSessionToken, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken };
    if (!isSeamHttpWithoutWorkspaceOptionsWithConsoleSessionToken(
      constructorOptions
    )) {
      throw new SeamHttpWithoutWorkspaceInvalidOptionsError(
        "Missing consoleSessionToken"
      );
    }
    return new _SeamHttpWithoutWorkspace(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, options = {}) {
    const constructorOptions = { ...options, personalAccessToken };
    if (!isSeamHttpWithoutWorkspaceOptionsWithPersonalAccessToken(
      constructorOptions
    )) {
      throw new SeamHttpWithoutWorkspaceInvalidOptionsError(
        "Missing personalAccessToken"
      );
    }
    return new _SeamHttpWithoutWorkspace(constructorOptions);
  }
  get workspaces() {
    return SeamHttpWorkspaces.fromClient(this.client, this.defaults);
  }
};
var SeamHttpMultiWorkspace = SeamHttpWithoutWorkspace;

// src/connect.ts
__reExport(connect_exports, url_search_params_serializer_star__namespace);

// src/index.ts
__reExport(index_exports, connect_exports);

exports.SeamActionAttemptError = SeamActionAttemptError;
exports.SeamActionAttemptFailedError = SeamActionAttemptFailedError;
exports.SeamActionAttemptTimeoutError = SeamActionAttemptTimeoutError;
exports.SeamHttp = SeamHttp;
exports.SeamHttpAccessCodes = SeamHttpAccessCodes;
exports.SeamHttpAccessCodesSimulate = SeamHttpAccessCodesSimulate;
exports.SeamHttpAccessCodesUnmanaged = SeamHttpAccessCodesUnmanaged;
exports.SeamHttpAccessGrants = SeamHttpAccessGrants;
exports.SeamHttpAccessGrantsUnmanaged = SeamHttpAccessGrantsUnmanaged;
exports.SeamHttpAccessMethods = SeamHttpAccessMethods;
exports.SeamHttpAccessMethodsUnmanaged = SeamHttpAccessMethodsUnmanaged;
exports.SeamHttpAcs = SeamHttpAcs;
exports.SeamHttpAcsAccessGroups = SeamHttpAcsAccessGroups;
exports.SeamHttpAcsAccessGroupsUnmanaged = SeamHttpAcsAccessGroupsUnmanaged;
exports.SeamHttpAcsCredentialPools = SeamHttpAcsCredentialPools;
exports.SeamHttpAcsCredentialProvisioningAutomations = SeamHttpAcsCredentialProvisioningAutomations;
exports.SeamHttpAcsCredentials = SeamHttpAcsCredentials;
exports.SeamHttpAcsCredentialsUnmanaged = SeamHttpAcsCredentialsUnmanaged;
exports.SeamHttpAcsEncoders = SeamHttpAcsEncoders;
exports.SeamHttpAcsEncodersSimulate = SeamHttpAcsEncodersSimulate;
exports.SeamHttpAcsEntrances = SeamHttpAcsEntrances;
exports.SeamHttpAcsSystems = SeamHttpAcsSystems;
exports.SeamHttpAcsUsers = SeamHttpAcsUsers;
exports.SeamHttpAcsUsersUnmanaged = SeamHttpAcsUsersUnmanaged;
exports.SeamHttpActionAttempts = SeamHttpActionAttempts;
exports.SeamHttpApiError = SeamHttpApiError;
exports.SeamHttpBridges = SeamHttpBridges;
exports.SeamHttpClientSessions = SeamHttpClientSessions;
exports.SeamHttpConnectWebviews = SeamHttpConnectWebviews;
exports.SeamHttpConnectedAccounts = SeamHttpConnectedAccounts;
exports.SeamHttpCustomers = SeamHttpCustomers;
exports.SeamHttpDevices = SeamHttpDevices;
exports.SeamHttpDevicesSimulate = SeamHttpDevicesSimulate;
exports.SeamHttpDevicesUnmanaged = SeamHttpDevicesUnmanaged;
exports.SeamHttpEndpoints = SeamHttpEndpoints;
exports.SeamHttpEndpointsWithoutWorkspace = SeamHttpEndpointsWithoutWorkspace;
exports.SeamHttpEvents = SeamHttpEvents;
exports.SeamHttpInstantKeys = SeamHttpInstantKeys;
exports.SeamHttpInvalidInputError = SeamHttpInvalidInputError;
exports.SeamHttpInvalidOptionsError = SeamHttpInvalidOptionsError;
exports.SeamHttpInvalidTokenError = SeamHttpInvalidTokenError;
exports.SeamHttpLocks = SeamHttpLocks;
exports.SeamHttpLocksSimulate = SeamHttpLocksSimulate;
exports.SeamHttpMultiWorkspace = SeamHttpMultiWorkspace;
exports.SeamHttpNoiseSensors = SeamHttpNoiseSensors;
exports.SeamHttpNoiseSensorsNoiseThresholds = SeamHttpNoiseSensorsNoiseThresholds;
exports.SeamHttpNoiseSensorsSimulate = SeamHttpNoiseSensorsSimulate;
exports.SeamHttpPhones = SeamHttpPhones;
exports.SeamHttpPhonesSimulate = SeamHttpPhonesSimulate;
exports.SeamHttpRequest = SeamHttpRequest;
exports.SeamHttpSeamConsole = SeamHttpSeamConsole;
exports.SeamHttpSeamConsoleV1 = SeamHttpSeamConsoleV1;
exports.SeamHttpSeamConsoleV1Timelines = SeamHttpSeamConsoleV1Timelines;
exports.SeamHttpSeamCustomerV1 = SeamHttpSeamCustomerV1;
exports.SeamHttpSeamCustomerV1AutomationRuns = SeamHttpSeamCustomerV1AutomationRuns;
exports.SeamHttpSeamCustomerV1Automations = SeamHttpSeamCustomerV1Automations;
exports.SeamHttpSeamCustomerV1Events = SeamHttpSeamCustomerV1Events;
exports.SeamHttpSeamCustomerV1Portals = SeamHttpSeamCustomerV1Portals;
exports.SeamHttpSeamCustomerV1Reservations = SeamHttpSeamCustomerV1Reservations;
exports.SeamHttpSeamCustomerV1Settings = SeamHttpSeamCustomerV1Settings;
exports.SeamHttpSeamCustomerV1Spaces = SeamHttpSeamCustomerV1Spaces;
exports.SeamHttpSeamPartnerV1BuildingBlocks = SeamHttpSeamPartnerV1BuildingBlocks;
exports.SeamHttpSeamPartnerV1BuildingBlocksSpaces = SeamHttpSeamPartnerV1BuildingBlocksSpaces;
exports.SeamHttpSpaces = SeamHttpSpaces;
exports.SeamHttpThermostats = SeamHttpThermostats;
exports.SeamHttpThermostatsDailyPrograms = SeamHttpThermostatsDailyPrograms;
exports.SeamHttpThermostatsSchedules = SeamHttpThermostatsSchedules;
exports.SeamHttpThermostatsSimulate = SeamHttpThermostatsSimulate;
exports.SeamHttpUnauthorizedError = SeamHttpUnauthorizedError;
exports.SeamHttpUnstablePartner = SeamHttpUnstablePartner;
exports.SeamHttpUnstablePartnerBuildingBlocks = SeamHttpUnstablePartnerBuildingBlocks;
exports.SeamHttpUserIdentities = SeamHttpUserIdentities;
exports.SeamHttpUserIdentitiesEnrollmentAutomations = SeamHttpUserIdentitiesEnrollmentAutomations;
exports.SeamHttpUserIdentitiesUnmanaged = SeamHttpUserIdentitiesUnmanaged;
exports.SeamHttpWebhooks = SeamHttpWebhooks;
exports.SeamHttpWithoutWorkspace = SeamHttpWithoutWorkspace;
exports.SeamHttpWithoutWorkspaceInvalidOptionsError = SeamHttpWithoutWorkspaceInvalidOptionsError;
exports.SeamHttpWorkspaces = SeamHttpWorkspaces;
exports.SeamHttpWorkspacesCustomizationProfiles = SeamHttpWorkspacesCustomizationProfiles;
exports.SeamPaginator = SeamPaginator;
exports.errorInterceptor = errorInterceptor;
exports.getOpenapiSchema = getOpenapiSchema;
exports.isApiKey = isApiKey;
exports.isClientSessionToken = isClientSessionToken;
exports.isConsoleSessionToken = isConsoleSessionToken;
exports.isPersonalAccessToken = isPersonalAccessToken;
exports.isPublishableKey = isPublishableKey;
exports.isSeamActionAttemptError = isSeamActionAttemptError;
exports.isSeamActionAttemptFailedError = isSeamActionAttemptFailedError;
exports.isSeamActionAttemptTimeoutError = isSeamActionAttemptTimeoutError;
exports.isSeamHttpApiError = isSeamHttpApiError;
exports.isSeamHttpInvalidInputError = isSeamHttpInvalidInputError;
exports.isSeamHttpOptionsWithApiKey = isSeamHttpOptionsWithApiKey;
exports.isSeamHttpOptionsWithClient = isSeamHttpOptionsWithClient;
exports.isSeamHttpOptionsWithClientSessionToken = isSeamHttpOptionsWithClientSessionToken;
exports.isSeamHttpOptionsWithConsoleSessionToken = isSeamHttpOptionsWithConsoleSessionToken;
exports.isSeamHttpOptionsWithPersonalAccessToken = isSeamHttpOptionsWithPersonalAccessToken;
exports.isSeamHttpUnauthorizedError = isSeamHttpUnauthorizedError;
exports.isSeamHttpWithoutWorkspaceOptionsWithClient = isSeamHttpWithoutWorkspaceOptionsWithClient;
exports.isSeamHttpWithoutWorkspaceOptionsWithConsoleSessionToken = isSeamHttpWithoutWorkspaceOptionsWithConsoleSessionToken;
exports.isSeamHttpWithoutWorkspaceOptionsWithPersonalAccessToken = isSeamHttpWithoutWorkspaceOptionsWithPersonalAccessToken;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map