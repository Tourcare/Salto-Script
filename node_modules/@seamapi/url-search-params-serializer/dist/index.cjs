'use strict';

// src/lib/date.ts
var isDateLike = (v) => {
  if (v == null) return false;
  if (typeof v !== "object") return false;
  if (v instanceof Date || Object.prototype.toString.call(v) === "[object Date]") {
    return "toISOString" in v;
  }
  return false;
};
var isTemporalInstantLike = (v) => {
  if (v == null) return false;
  if (typeof v !== "object") return false;
  if (!("epochMilliseconds" in v)) return false;
  try {
    if (typeof v.epochMilliseconds !== "number") return false;
    if (isNaN(v.epochMilliseconds)) return false;
    return true;
  } catch {
    return false;
  }
};

// src/lib/object.ts
var isPlainObject = (v) => {
  if (v == null) return false;
  if (typeof v !== "object") return false;
  const proto = Object.getPrototypeOf(v);
  if (proto === null) return true;
  if (proto === Object.prototype) return true;
  return false;
};

// src/lib/serialize.ts
var serializeUrlSearchParams = (params) => {
  const searchParams = new URLSearchParams();
  updateUrlSearchParams(searchParams, params);
  return searchParams.toString();
};
var updateUrlSearchParams = (searchParams, params) => {
  nestedUpdateUrlSearchParams(searchParams, params, []);
  searchParams.sort();
};
var nestedUpdateUrlSearchParams = (searchParams, params, path) => {
  for (const [key, value] of Object.entries(params)) {
    if (key.includes(".")) {
      throw new UnserializableParamError(
        key,
        'contains one or more dots "." in its name which is unsupported'
      );
    }
    const currentPath = [...path, key];
    if (isPlainObject(value)) {
      nestedUpdateUrlSearchParams(searchParams, value, currentPath);
      return;
    }
    const name = currentPath.join(".");
    if (value == null && value !== null) {
      continue;
    }
    if (Array.isArray(value)) {
      if (value.length === 0) {
        searchParams.set(name, "");
        continue;
      }
      if (value.length === 1 && value[0] === "") {
        throw new UnserializableParamError(
          name,
          "is a single element array containing the empty string which is unsupported"
        );
      }
      if (value.some((v) => v === "")) {
        throw new UnserializableParamError(
          name,
          "is an array containing the empty string which is unsupported"
        );
      }
      if (value.some((v) => v == null)) {
        throw new UnserializableParamError(
          name,
          "is an array containing null or undefined values which is unsupported"
        );
      }
      for (const v of value) {
        searchParams.append(name, serialize(name, v));
      }
      continue;
    }
    searchParams.set(name, serialize(name, value));
  }
};
var serialize = (k, v) => {
  if (v === null) return "";
  if (typeof v === "string") {
    if (v.length === 0) {
      throw new UnserializableParamError(
        k,
        "is the empty string which is unsupported"
      );
    }
    return v.toString();
  }
  if (typeof v === "number") {
    if (isNaN(v) || v === Infinity || v === -Infinity || v.toString() === "NaN" || v.toString() === "Infinity" || v.toString() === "-Infinity") {
      throw new UnserializableParamError(k, `is ${v}`);
    }
    return v.toString();
  }
  if (typeof v === "bigint") return v.toString();
  if (typeof v === "boolean") return v.toString();
  if (isDateLike(v)) return v.toISOString();
  if (isTemporalInstantLike(v)) {
    return new Date(v.epochMilliseconds).toISOString();
  }
  throw new UnserializableParamError(k, `is a ${typeof v}`);
};
var UnserializableParamError = class extends Error {
  constructor(name, message) {
    super(`Could not serialize parameter: '${name}' ${message}`);
    this.name = this.constructor.name;
  }
};

exports.UnserializableParamError = UnserializableParamError;
exports.serializeUrlSearchParams = serializeUrlSearchParams;
exports.updateUrlSearchParams = updateUrlSearchParams;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map